#  python笔记

##  进入python终端
	*  进入系统命令行，输入对应的python版本(python2/python3)，进入python终端，可输入python语法对应语句

##  python语法
	###	代码风格
		*	注释
			```
				Python 的注释以 # 字符开始的，在 # 字符到行尾之间的所有东西都被程序忽略为注释，也就说对程序没有任何影响。你应该总是在 # 后跟一个空格，然后再写注释。

				>>> # 这是一个注释
				>>> # 下面这一行是求两数之和
				>>> a = 12 + 34
				>>> print(a) # 这里也是注释 :)

				# FIXME -- fix these code later
				# TODO -- in future you have to do this
			```
			```
				多行注释("""   """)
				虽然井号字符（#）表示这一行是注释，但多行字符串常常用作多行注释。
				"""This is a test Python program. 
				Written by Al Sweigart al@inventwithpython.com 
				 
				This program was designed for Python 3, not Python 2. 
				""" 
				 
				def spam(): 
				    """This is a multiline comment to help 
				    explain what the spam() function does.""" 
				    print('Hello!') 
			```
			```
				建议遵守以下约定：

				使用 4 个空格来缩进
				永远不要混用空格和制表符
				在函数之间空一行
				在类之间空两行
				字典，列表，元组以及参数列表中，在 , 后添加一个空格。对于字典，: 后面也添加一个空格
				在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里则不加空格：a = f(1, 2) + g(3, 4)
			```
			```
				Python 中缩进规则的例外 在大多数情况下，代码行的缩进告诉 Python 它属于哪一个代码块。但是，这个规则有几个例外。例如在源代码文件中，列表实际上可以跨越几行。这些行的缩进并不重要。Python 知道，没有看到结束方括号，列表就没有结束。例如，代码可以看起来像这样： 
 
				spam = ['apples', 
				    'oranges', 
				                    'bananas', 
				'cats'] 
				print(spam) 
				 
				当然，从实践的角度来说，大部分人会利用 Python 的行为，让他们的列表看起来漂亮且可读，就像神奇 8 球程序中的消息列表一样。 也可以在行末使用续行字符\，将一条指令写成多行。可以把\看成是“这条指令在下一行继续” 。\续行字符之后的一行中，缩进并不重要。例如，下面是有效的 Python 代码： 
				 
				print('Four score and seven ' + \ 
				      'years ago...') 
				 
				如果希望将一长行的 Python 代码安排得更为可读，这些技巧是有用的。 
			```
	###	python项目代码构成
		*	模块
			在开始使用一个模块中的函数之前， 必须用 import 语句导入该模块。
			import 语句的另一种形式包括 from 关键字，之后是模块名称，import 关键字和一个星号，例如 from random import *。 使用这种形式的import语句， 调用random模块中的函数时不需要random.前缀。但是，使用完整的名称会让代码更可读，所以最好是使用普通形式的 import 语句。

			```
				在代码中，import 语句包含以下部分：  
				  import 关键字； 
				  模块的名称； 
				  可选的更多模块名称，之间用逗号隔开。
				
				import random, sys, os, math
			```
			```
				模块是包含了我们能复用的代码的文件，包含了不同的函数定义，变量。模块文件通常以 .py 为扩展名。
				Python 本身在默认安装时就带有大量的模块。我们之后将会用到其中的一部分。在使用模块前先导入它。
				Python 程序可以调用一组基本的函数，这称为“内建函数” ，包括你见到过的print()、input()和 len()函数。Python 也包括一组模块，称为“标准库” 。每个模块都是一个 Python 程序，包含一组相关的函数，可以嵌入你的程序之中。例如，math模块有数学运算相关的函数，random 模块有随机数相关的函数，等等。

				>>> import math    # 导入math模块
				>>> print(math.e)
				2.71828182846
			```
			-	安装第三方模块
				```
					除了 Python 自带的标准库， 其他开发者写了一些自己的模块， 进一步扩展了 Python 的功能。 安装第三方模块的主要方法是使用 Python 的 pip 工具。这个工具从 Python 软件基金会的网站 https://pypi.python.org/安全地下载 Python 模块，并安装到您的计算机上。 PyPI或Python 包索引， 就像是 Python 模块的免费应用程序商店。 
				```
				1.	pip工具
					```
						pip 工具的可执行文件在 Windows 上称为pip，在OS X 和 Linux 上称为pip3。在Windows 上，pip 位于 C:\Python34\Scripts\pip.exe。在 OS X 上，它位于/Library/ Frameworks/Python.framework/Versions/3.4/bin/pip3。在Linux 上，它位于/usr/bin/pip3。 
					```
				2.	安装第三方模块
					-	pip 工具需要在命令行中运行： 向它传入 install 命令， 跟上想要安装的模块名称。
						```
							如果你已经安装了模块， 但想升级到 PyPI 上提供的最新版本， 就运行 pip install –U ModuleName（或在OS X 和 Linux 上运行pip3 install –U ModuleName） 。 安装模块后，可以在交互式环境中运行import ModuleName，测试安装是否成功。如果未显示错误信息，就可以认为该模块已经成功安装。 
						```
						```
							运行下面列出的命令，你可以安装本书中介绍的所有模块（请记住，如果在 OS X 或 Linux 上，用 pip3 替代 pip） 。 
							•  pip install send2trash 
							•  pip install requests 
							•  pip install beautifulsoup4 
							•  pip install selenium 
							•  pip install openpyxl 
							•  pip install PyPDF2 
							•  pip install python-docx（安装 python-docx，而不是 docx） 
							•  pip install imapclient 
							•  pip install pyzmail 
							•  pip install twilio 
							•  pip install pillow 
							•  pip install pyobjc-core（仅在 OS X 上） 
							•  pip install pyobjc（仅在 OS X 上） 
							•  pip install python3-xlib（仅在 Linux 上） 
							•  pip install pyautogui 
							对于 OS X 用户：pyobjc 模块需要 20 分钟或更长的时间来安装，因此，如果它需要一段时间， 不要惊慌。 也应该先安装 pyobjc 核心模块， 这将减少整体安装时间。  
						```

	###	关键字和标识符
		*	关键字
			```
				False               def                 if                  raise
				None                del                 import              return
				True                elif                in                  try
				and                 else                is                  while
				as                  except              lambda              with
				assert              finally             nonlocal            yield
				break               for                 not
				class               from                or
				continue            global              pass
			```

	###  python数据类型
		*	在 Python 中 我们不需要为变量指定数据类型，只需要输入变量名和值就行了
		*	Python 中赋值语句执行时会先对赋值运算符右边的表达式求值，然后将这个值赋值给左边的变量。
		*  int-整型，
			-  包括正整数和负整数，不带小数点，最大值和最小值为计算机的
		*  float-浮点值，
			-  小数，小数点的位置可以改变位置。
			    在计算机中，整数、浮点数字、字符串等所有的数据，都会被转换为二进制数值进行处理，处理完成后再转换为你想要的信息。转换的过程中可能就会出现精度的丢失
			-	数字的字符串值被认为与整型值和浮点型值完全不同， 但整型值可以与浮点值相等
		*  布尔值，
			-  只有True和False，通常用来比较和判断
			-	Boolean（布尔）的首字母大写，True or False
		*  空值None，
			-  None在 Python 中是一个特殊的值，表示“无”。注意它与数值 0 不同，0 是一个整数，而 无 表示什么都没有。
		*  字符串，
			-  用 引号 包裹起来的数据就是字符串。计算机无法识别人类的文字，所以引号的作用就是告诉计算机：我是字符串，不用管里面是什么内容。
			-  字符串的内容总是很长。这是因为：处理字符串是计算机程序中最普遍的需求之一，人和计算机交互，所用的就是字符串而不是二进制数字。
			-	字符串可以用双引号开始和结束， 就像用单引号一样。 使用双引号的一个好处，就是字符串中可以使用单引号字符。如果在字符串中既需要使用单引号又需要使用双引号，那就要使用转义字符。
			-  包裹字符串的引号必须前后对应，成对出现。如果字符串中还有引号，要特别注意，如 He said "Today's weather is good."，直接写 print('He said "Today's weather is good."') 就会报错。正确的写法是，在 Today 后面加入转义符 \。转义符 \ 还有一个常用形式是和 n 连起来用，\n 代表换行符，
			-	转义字符
				```
					“转义字符”让你输入一些字符，它们用其他方式是不可能放在字符串里的。转义字符包含一个倒斜杠 （\） ， 紧跟着是想要添加到字符串中的字符。 （尽管它包含两个字符，但大家公认它是一个转义字符。 ）例如，单引号的转义字符是\’。你可以在单引号开始和结束的字符串中使用它。转义字符\'和\"让你能在字符串中加入单引号和双引号。
				```
				*	转义字符
					|	转义字符 	|	打印为	|
					|	\' 			|	单引号	|
					|	\" 			|	双引号	|
					|	\t 			|	制表符	|
					|	\n 			|	换行符	|
					|	\\ 			|	倒斜杠	|
			-	原始字符串
				*	可以在字符串开始的引号之前加上r，使它成为原始字符串。“原始字符串”完全忽略所有的转义字符，打印出-符串中所有的倒斜杠。
				*	因为这是原始字符串，Python 认为倒斜杠是字符串的一部分，而不是转义字符的开始。如果输入的字符串包含许多倒斜杠，比如下一章中要介绍的正则表达式字符串，那么原始字符串就很有用。
			-	三重引号的多行字符串
				*	多行字符串的起止是3个单引号或3个双引号。“三重引号”之间的所有引号、制表符或换行，都被认为是字符串的一部分。**Python 的代码块缩进规则不适用于多行字符串。 **
			-  索引。
				*  字符串是一堆字符的集合，可以通过位置编号，来获得对应的字符。如 'hello_shiyanlou'，编号 0 对应第一个字符 h，1 对应第二个字符 e，依次类推。这个位置的编号，我们称之为：索引。
				*  在计算机世界中，计数从 0 开始。
				*  索引除了是正数，也可以是 负值，表示倒数第几个。比如最后一个字符的索引为 -1，倒数第二个字符的索引为 -2。
			-	字符串的下标与切片
				*	如果指定一个下标，你将得到字符串在该处的字符。如果用一个下标和另一个下标指定一个范围， 开始下标将被包含， 结束下标则不包含。 因此， 如果 spam是'Hello world!'，spam[0:5]就是'Hello'。通过 spam[0:5]得到的子字符串，将包含 spam[0]到spam[4]的全部内容，而**不包括下标 5 处的空格**。
				*	请注意，字符串切片并没有修改原来的字符串。可以从一个变量中获取切片，记录在另一个变量中。通过切片并将结果子字符串保存在另一个变量中，就可以同时拥有完整的字符串和子字符串，便于快速简单的访问。 
			-	字符串的in 和not in 操作符
				*	in 和 not in 操作符也可以用于字符串。用 in 或 not in 连接两个字符串得到的表达式，将求值为布尔值 True 或 False。**这些表达式测试第一个字符串（精确匹配，区分大小写）是否在第二个字符串中。**
			-	有用的字符串方法
				*	upper() -- 返回原字符串的大写，其他非字母字符保持不变。
				*	lower() -- 返回原字符串的小写，其他非字母字符保持不变。
				*	因为 upper()和 lower()字符串方法本身返回字符串，所以也可以在“那些”返回的字符串上继续调用字符串方法。这样做的表达式看起来就像方法调用链。
				*	isupper() -- 如果字符串至少有一个字母，并且所有字母都是大写，isupper()方法就会相应地返回布尔值 True。否则，该方法返回 False。
				*	islower() --  如果字符串至少有一个字母，并且所有字母都是大写，islower()方法就会相应地返回布尔值 True。否则，该方法返回 False。
				*	isX方法
					-	除了 islower()和 isupper()，还有几个字符串方法，它们的名字以 is 开始。这些方法返回一个布尔值，描述了字符串的特点。下面是一些常用的 isX 字符串方法： 
					-	isalpha()返回 True，如果字符串只包含字母，并且非空； 
					-	isalnum()返回 True，如果字符串只包含字母和数字，并且非空； 
					-	isdecimal()返回 True，如果字符串只包含数字字符，并且非空； 
					-	isspace()返回 True，如果字符串只包含空格、制表符和换行，并且非空； 
					-	istitle()返回True， 如果字符串仅包含以大写字母开头、 后面都是小写字母的单词。  
				*	startswith()  --  如果该字符串以传入的字符串为开始，返回True，否则返回False。
				*	endswith()  --  如果该字符串以传入的字符串为结尾，返回True，否则返回False。
					```
						>>>spam = 'Hello world'
						>>>spam.startswith('Hello')
						True
						>>>spam.endswith('world')
						True
						>>>spam.startswith('Hello world')
						True
						>>>spam.endswith('Hello world')
					```
				*	join()  --  使用调用的字符串拼接传入的字符串列表(不能包含整数或其他类型)。
				*	split()  -- 把字符串按照传入的分割字符分割，返回一个字符串列表。分割字符不包含在返回列表的字符串中。向 split()方法传入参数’\n’，我们按照换行符分割变量中存储的多行字符串，返回列表中的每个表项，对应于字符串中的一行
				*	rjust()  -- 返回调用它们的字符串的填充版本，以右对齐文本，a.ljust(12, '='): 第一个参数为总字符长度，第二个为填充字符(默认是空格)
				*	ljust()  --  返回调用它们的字符串的填充版本，以左对齐文本，a.rjust(12, '*'): 第一个参数为总字符长度，第二个为填充字符(默认是空格)
				*	center()  --  返回调用它们的字符串的填充版本，以中间对齐文本，a.ljust(12, '='): 第一个参数为总字符长度，第二个为填充字符(默认是空格)
				*	strip() -- 删除字符串两边空白字符，一个可选参数，指定两边哪些字符应该被删除，'abcabcaaaabcabcabc'.strip('abc')，传入的参数不分先后顺序
				*	rstrip() --  删除字符串右边空白字符
				*	lstrip()  --  删除字符串左边空白字符
			-	小结
				```
					文本是常见的数据形式，Python自带了许多有用的字符串方法，来处理保存在字符串中的文本。在你写的几乎每个Python 程序中，都会用到取下标、切片和字符串方法。
					现在你写的程序似乎不太复杂，因为它们没有图形用户界面，没有图像和彩色的文本。到目前为止，你在利用 print()显示文本，利用 input()让用户输入文本。但是，用户可以通过剪贴板，快速输入大量的文本。这种能力提供了一种有用的编程方式，可以操作大量的文本。这些基于文本的程序可能没有闪亮的窗口或图形，但它们能很快完成大量有用的工作。 
					操作大量文本的另一种方式，是直接从硬盘读写文件。在下一章中，你将学习如何用 Python 来做到这一点。
				```
		*  列表，
			-	列表的数据结构。它可以写作中括号之间的一列逗号分隔的值。列表的元素不必是同一类型。
				```
					>>> a = [ 1, 342, 223, 'India', 'Fedora']
					>>> a
					[1, 342, 223, 'India', 'Fedora']

					#	编号从零开始，你可以通过编号访问每一个盒子里面的值。对于列表，这里的编号称为索引
					>>> a[0]
					1
					>>> a[4]
					'Fedora'

					#	如果我们使用负数的索引，那将会从列表的末尾开始计数，像下面这样
					>>> a[-1]
					'Fedora'

					#	你甚至可以把它切成不同的部分，这个操作称为切片，例子在下面给出：
					>>> a[0:-1]
					[1, 342, 223, 'India']
					>>> a[2:-2]
					[223]
					#	切片并不会改变正在操作的列表，切片操作返回其子列表，这意味着下面的切片操作返回列表一个新的（栈）拷贝副本：
					>>> a[:]
					[1, 342, 223, 'India', 'Fedora']
					#	切片的索引有非常有用的默认值；省略的第一个索引默认为零，省略的第二个索引默认为切片的索引的大小。如果是字符串，则为字符串大小。作为快捷方法，你可以省略切片中冒号两边的一个下标或两个下标。省略第一个下标相当于使用 0，或列表的开始。省略第二个下标相当于使用列表的长度，意味着分片直至列表的末尾。
					>>> a[:-2]
					[1, 342, 223]
					>>> a[-2:]
					['India', 'Fedora']
					#	有个办法可以很容易地记住切片的工作方式：切片时的索引是在两个元素之间 。左边第一个元素的索引为 0，而长度为 n 的列表其最后一个元素的右界索引为 n。例如
					 +---+-----+-----+---------+----------+
					 | 1 | 342 | 223 | 'India' | 'Fedora' |
					 +---+-----+-----+---------+----------+
					   0    	1     	2       	3        		4          5
					  -5   	-4    	-3      	-2      		 -1
				```
			-	列表本身又可以包含其他列表，所以可以用它们将数据安排成层次结构。**使用列表的好处在于，现在数据放在一个结构中，所以程序能够更灵活的处理数据，比放在一些重复的变量中方便。**
			-	如果使用的下标超出了列表中值的个数，Python 将给出 IndexError 出错信息。 
			-	下标只能是整数，不能是浮点值。下面的例子将导致 TypeError 错误
			-	列表也可以包含其他列表值。这些列表的列表中的值，可以通过多重下标来访问。
			-	列表的操作
				1.	列表连接和列表复制
					-	+操作符可以连接两个列表，得到一个新列表，就像它将两个字符串合并成一个新字符串一样。*操作符可以用于一个列表和一个整数，实现列表的复制。
				2.	用 del 语句从列表中删除值
					-	del 语句将删除列表中下标处的值，表中被删除值后面的所有值，都将**向前移动一个下标**。
						```
							**del 语句也可用于一个简单变量，删除它，作用就像是“取消赋值”语句。如果在删除之后试图使用该变量，就会遇到NameError 错误，因为该变量已不再存在。** 在实践中，你几乎永远不需要删除简单变量。del 语句几乎总是用于删除列表中的值。 
						```
				3.	列表的遍历
					-	从技术上说，循环是针对一个列表或类似列表中的每个值，重复地执行代码块。
					-	**一个常见的 Python 技巧，是在 for 循环中使用 range(len(someList))，迭代列表的每一个下标。**
						```
							c = ['A', 'B', 'C']
							for i in c:
								print(i)
							for i in range(len(c)):
								print('Index {} in  supplies is: {}'.format(i,c[i]))
						```
				4.	in和not in 操作符
					1.	利用in和 not in 操作符，可以判断一个值是否在列表中
				5.	多重赋值技巧
					1.	多重赋值技巧是一种快捷方式，让你在一行代码中，用列表中的值为多个变量赋值。**但是变量的数目和列表的长度必须严格相等，否则 Python 将给出 ValueError。**
						```
							cat = ['fat', 'black', 'loud']
							size = cat[0]
							color = cat[1]
							disposition = cat[2]

							size, color, disposition = cat
						```
				6.	列表操作方法
					*	index() -- 用于返回传入值在列表中的下标，如果不存在则报ValueError错误。如果列表中存在重复的值，就返回它第一次出现的下标：a.index('a')
					*	append() -- 用于向列表中插入（尾部追加）值
					*	insert() -- 用于向列表中（任意下标处）插入值，a.insert(2, 'a')，第一个参数为列表指定下标，第二个参数为要插入的值。当指定下标大于列表最大下标时候，默认为在列表尾部添加元素
					*	remove() -- 删除列表中与传入参数对应的值，如果没有则返回ValueError。如果该值在列表中出现多次，只有第一次出现的值会被删除。**如果知道想要删除的值在列表中的下标，del语句就很好用。如果知道想要从列表中删除的值，remove()方法就很好用。**
					*	pop()  --  删除指定位置(下标)的元素,返回被删除的元素
					*	sort() -- 数值的列表**或者**字符串的列表，能用sort()方法进行排序。也可以指定 reverse 关键字参数为 True，让 sort()按逆序排序。
						tips:	
						1.	sort()方法当场对列表排序。不要写出 spam = spam.sort()这样的代码，试图记录返回值。
						2.	不能对既有数字又有字符串值的列表排序， 因为 Python 不知道如何比较它们。在交互式环境中输入以下代码，注意 TypeError 错误
						3.	sort()方法对字符串排序时，使用“ASCII 字符顺序” ，而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时，小写的 a 在大写的Z 之后。如果需要按照普通的字典顺序来排序，就在 sort()方法调用时，将关键字参数key 设置为str.lower。这将导致 sort()方法将列表中所有的表项当成小写，但实际上并不会改变它们在列表中的值。
						```
							spam = ['a', 'z', 'A', 'Z'] 
							>>> spam.sort(key=str.lower) 
							>>> spam 
							['a', 'A', 'z', 'Z'] 
						```
			-	类似列表的类型：字符串和元组
				```
					列表并不是唯一表示序列值的数据类型。例如，字符串和列表实际上很相似，只要你认为**字符串是单个文本字符的列表**。对列表的许多操作，也可以作用于字符串：按下标取值、切片、用于 for 循环、用于 len()，以及用于 in 和 not in 操作符。
				```
			-	可变和不可变数据类型
				```
					但列表和字符串在一个重要的方面是不同的。**列表是“可变的”数据类型，它的值可以添加、删除或改变。但是，字符串是“不可变的” ，它不能被更改。**尝试对字符串中的一个字符重新赋值，将导致 TypeError 错误。

					“改变”一个字符串的正确方式，是使用切片和连接。构造一个“新的”字符串，从老的字符串那里复制一些部分。

					尽管列表值是可变的，但下面代码中的第二行并没有修改列表 eggs：
					# 当 eggs = [4, 5, 6]被执行时，eggs 的内容被新的列表值取代 
					eggs = [1, 2, 3] 
					>>> eggs = [4, 5, 6] 
					>>> eggs 
					[4, 5, 6] 
					这里 eggs 中的列表值并没有改变，而是整个新的不同的列表值([4, 5, 6])，覆写了老的列表值。
					# 如果你确实希望修改 eggs 中原来的列表，让它包含[4, 5, 6]，就要这样做
					>>> eggs = [1, 2, 3] 
					>>> del eggs[2] 
					>>> del eggs[1] 
					>>> del eggs[0] 
					>>> eggs.append(4) 
					>>> eggs.append(5) 
					>>> eggs.append(6) 
					>>> eggs 
					[4, 5, 6] 
					在第一个例子中，eggs 最后的列表值与它开始的列表值是一样的。只是这个列表被改变了，而不是被覆写。改变一个可变数据类型的值（就像前面例子中 del 语句和 append()方法所做的事） ，当场改变了该值，因为该变量的值没有被一个新的列表值取代。 
					区分可变与不可变类型，似乎没有什么意义，但 4.7.1 节“传递引用”将解释，使用可变参数和不可变参数调用函数时产生的不同行为。首先，让我们来看看**元组数据类型，它是列表数据类型的不可变形式。 **
				```
			-	引用
				```
					正如你看到的，变量保存字符串和整数值。
					>>> spam = 42 
					>>> cheese = spam 
					>>> spam = 100 
					>>> spam 
					100 
					>>> cheese 
					42
					# 你将 42 赋给 spam 变量，然后拷贝 spam 中的值，将它赋给变量 cheese。当稍后将 spam中的值改变为 100 时， 这不会影响cheese中的值。 这是因为 spam和 cheese是不同的变量，保存了不同的值。

					但列表不是这样的。当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。这里有一些代码，让这个概念更容易理解。
					>>> spam = [0, 1, 2, 3, 4, 5] 
					 >>> cheese = spam 
					 >>> cheese[1] = 'Hello!' 
					>>> spam 
					[0, 'Hello!', 2, 3, 4, 5] 
					>>> cheese 
					[0, 'Hello!', 2, 3, 4, 5] 
					当创建列表时， 你将对它的引用赋给了变量。 但下一行只是将 spam 中的列表引用拷贝到 cheese，而不是列表值本身。这意味着存储在spam和cheese中的值，现在指向了同一个列表。底下只有一个列表，因为列表本身实际从未复制。所以当你修改 cheese 变量的第一个元素时，也修改了 spam 指向的同一个列表。 
					记住，变量就像包含着值的盒子。本章前面的图显示列表在盒子中，这并不准确，因为列表变量实际上没有包含列表，而是包含了对列表的“引用” （这些引用包含一些 ID 数字，Python 在内部使用这些 ID，但是你可以忽略） 。利用盒子作为变量的隐喻，图 4-4 展示了列表被赋给 spam 变量时发生的情形。 
				```
				```
					变量包含对列表值的引用，而不是列表值本身。但对于字符串和整数值，变量就包含了字符串或整数值。 在变量必须保存可变数据类型的值时， 例如列表或字典，Python 就使用引用。 对于不可变的数据类型的值， 例如字符串、 整型或元组， Python变量就保存值本身。 
					虽然 Python 变量在技术上包含了对列表或字典值的引用，但人们通常随意地说，该变量包含了列表或字典。

					#	列表引用典型(列表引用引用的是地址)
					def printModel(unprintedDesigns, completedModels):
						currentDesign = unprintedDesigns.pop()
						print('Printing Model: ' + currentDesign)
						completedModels.append(currentDesign)

					def showCompletedModel(completedModels):
						for completedModel in completedModels:
							print(completedModel)

					unprintedDesigns = ['dodecahedron', 'robot pendant', 'iphone case']
					completedModels = []

					printModel(unprintedDesigns, completedModels)
					print('The following Models have been printed: ')
					showCompletedModel(completedModels)
				```
				```
					#	要理解参数如何传递给函数，引用就特别重要。当函数被调用时，参数的值被复制给变元。对于列表（以及字典，我将在下一章中讨论），这意味着变元得到的是引用的拷贝。要看看这导致的后果，请打开一个新的文件编辑器窗口，输入以下代码，并保存为 passingReference.py：
					# passingReference.py
					def eggs(someParameter):
						someParameter.append('Hello')

					spam = [1, 2, 3]
					eggs(spam)
					print(spam)
					# 请注意，当 eggs()被调用时，没有使用返回值来为spam赋新值。相反，它直接当场修改了该列表。在运行时，该程序产生输出如下：[1, 2, 3, 'Hello']
					尽管spam和someParameter 包含了不同的引用， 但它们都指向相同的列表。这就是为什么函数内的append('Hello')方法调用在函数调用返回后，仍然会对该列表产生影响。  请记住这种行为： 如果忘了 Python 处理列表和字典变量时采用这种方式， 可能会导致令人困惑的缺陷。
				```
				-	copy模块中的copy()和deepcopy()函数
					在处理列表和字典时，尽管传递引用常常是最方便的方法，但如果函数修改了传入的列表或字典， 你可能不希望这些变动影响原来的列表或字典。 要做到这一点，Python 提供了名为 copy 的模块，其中包含copy()和deepcopy()函数。
					第一个函数copy.copy()，可以用来复制列表或字典这样的可变值，而不只是复制引用。
					如果要复制的列表中**包含了列表**，那就使用copy.deepcopy()函数来代替。deepcopy()函数将同时复制它们内部的列表。
					```
						>>> import copy 
						>>> spam = ['A', 'B', 'C', 'D'] 
						>>> cheese = copy.copy(spam) 
						>>> cheese[1] = 42 
						>>> spam 
						['A', 'B', 'C', 'D'] 
						>>> cheese 
						['A', 42, 'C', 'D']
						# 现在 spam 和 cheese 变量指向独立的列表，这就是为什么当你将 42 赋给下标 7时，只有 cheese 中的列表被改变。
					```
			-	小结
				1.	列表是有用的数据类型，因为它们让你写代码处理一组可以修改的值，同时仅用一个变量。在本书后面的章节中，你会看到一些程序利用列表来完成工作。没有列表，这些工作很困难，甚至不可能完成。 
				2.	列表是可变的，这意味着它们的内容可以改变。元组和字符串虽然在某些方面像列表，却是不可变的，不能被修改。包含一个元组或字符串的变量，可以被一个新的元组或字符串覆写，但这和现场修改原来的值不是一回事，不像 append()和remove()方法在列表上的效果。 
				3.	变量不直接保存列表值，它们保存对列表的“引用” 。在复制变量或将列表作为函数调用的参数时，这一点很重要。因为被复制的只是列表引用，所以要注意，对该列表的所有改动都可能影响到程序中的其他变量。如果需要对一个变量中的列表修改，同时不修改原来的列表，就可以用 copy()或 deepcopy()。 

		*  元组，
			-	除了两个方面， “元组”数据类型几乎与列表数据类型一样。首先，元组输入时用圆括号()，而不是用方括号[]。但元组列表的主要区别还在于，元组像字符串一样，是不可变的。元组不能让它们的值被修改、添加或删除。
				```
					如果元组中只有一个值，你可以在括号内该值的后面跟上一个逗号，表明这种情况。否则，Python将认为，你只是在一个普通括号内输入了一个值。逗号告诉Python，这是一个元组（不像其他编程语言，Python 接受列表或元组中最后表项后面跟的逗号） 。在交互式环境中，输入以下的 type()函数调用，看看它们的区别：
					>>> type(('hello',)) 
					<class 'tuple'> 
					>>> type(('hello')) 
					<class 'str'> 
				```
				```
					你可以用元组告诉所有读代码的人，你不打算改变这个序列的值。**如果需要一个永远不会改变的值的序列，就使用元组。**使用元组而不是列表的第二个好处在于，因为它们是不可变的，它们的内容不会变化，**Python 可以实现一些优化，让使用元组的代码比使用列表的代码更快。 **
				```
			-	元组的封装和解封
				```
					#	要明白这是怎么工作的，你需要学习元组（_tuple_）这个数据类型。我们是用逗号创建元组。在赋值语句的右边我们创建了一个元组，我们称这为元组封装（_tuple packing_），赋值语句的左边我们则做的是元组拆封 （_tuple unpacking_）。
					a, b = b, a
					data = ('Shiyanlou','China','Python')
					name, country, language = data
				```
			-	列表与元组的互相转换
				函数 list()和 tuple()将返回传递给它们的值的列表和元组版本，如果需要元组值的一个可变版本，将元组转换成列表就很方便
		*  字典，
			-	字典数据类型，它提供了一种灵活的访问和组织数据的方式。像列表一样，“字典”是许多值的集合。**但不像列表的下标，字典的索引可以使用许多不同数据类型，不只是整数。**字典的索引被称为“键” ，键及其关联的值称为“键-值”对。
			-	在代码中，字典输入时带花括号{}。 
			-	字典和列表
				1.	字典仍然可以用整数值作为键，就像列表使用整数值作为下标一样，但它们不必从 0 开始，可以是任何数字。
					**不像列表， 字典中的表项是不排序的。 **名为 spam 的列表中， 第一个表项是spam[0]。但字典中没有“第一个”表项。虽然确定两个列表是否相同时，表项的顺序很重要，但在字典中，键-值对输入的顺序并不重要。
					```
						>>>a = ['A', 'a']
						>>>aa = ['a', 'A']
						>>>a == aa
						False
						>>>b = {'B', 'b'}
						>>>bb = {'b', 'B'}
						>>>b == bb
						True
					```
				2.	因为字典是不排序的，所以不能像列表那样切片。
				3.	尝试访问字典中不存在的键， 将导致 KeyError 出错信息。 这很像列表的 “越界”IndexError 出错信息。
					```
						>>> myCat = {'size': 'fat', 'color': 'grey', 'disposition': 'loud'}
						>>> myCat['size']
						'fat'
						>>> myCat[0]
						Traceback (most recent call last):
						  File "<console>", line 1, in <module>
						KeyError: 0
						>>> myCat[0] = '56'
						>>> myCat[0]
						'56'
					```
				4.	列表适用于包含一组有序的值，字典适合于包含关联的键与值。
			-	尽管字典是不排序的，但可以用任意值作为键，这一点让你能够用强大的方式来组织数据。
			-	字典方法
				1.	keys() -- 返回字典的键
				2.	values() -- 返回字典的值
				3.	items() -- 返回字典的键值对（返回的dicr_items值中包含的键和值的元组）  # 这3个字典方法， 它们将返回类似列表的值，这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型（分别是dict_keys、dict_values 和dict_items）可以用于for 循环。希望通过这些方法得到一个真正的列表，就把类似列表的返回值传递给 list函数。
					```
						# 检查键或值是否在字典内
						a = {'A': 'a', 'B': 'b','C': 'c'}
						'A' in a.keys()
						'b' in a.values()
					```
				4.	get() -- 它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。a.get('A', 'aa')(不会修改原来字典的值)
				5.	setdefault() -- 为字典中某个键设置一个默认值，当该键没有任何值时使用它。第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。如果该键确实存在，方法就会返回键的值。a.setdefault('B', 'b')(会修改原来字典的值)
			-	漂亮打印
				-	引入pprint模块之后，可以用pprint.pprint()方法对字典类型进行格式话打印。如果想要把 格式化打印的文本作为字符串，可以用pprint.pformat方法。
					```
						# 这两行代码是等价的
						pprint.pprint(someDictionaryValue)
						print(pprint.pformat(someDictionaryValue))
					```
			-	使用数据结构对真实世界进行建模
				```
					甚至在因特网之前，人们也有办法与世界另一边的某人下一盘国际象棋。每个棋手在自己家里放好一个棋盘，然后轮流向对方寄出明信片，描述每一着棋。要做到这一点，棋手需要一种方法，无二义地描述棋盘的状态，以及他们的着法。 
					在“代数记谱法”中，棋盘空间由一个数字和字母坐标确定，如图 5-1 所示。 
					棋子用字母表示：K 表示王，Q 表示后，R 表示车，B 表示象，N 表示马。描述一次移动，用棋子的字母和它的目的地坐标。一对这样的移动表示一个回合（白方先下） ，例如， 棋谱2. Nf3 Nc6 表明在棋局的第二回合， 白方将马移动到f3， 黑方将马移动到c6。  
					代数记谱法还有更多内容，但要点是你可以用它无二义地描述象棋游戏，不需要站在棋盘前。你的对手甚至可以在世界的另一边！实际上，如果你的记忆力很好，甚至不需要物理的棋具：只需要阅读寄来的棋子移动，更新心里想的棋盘。 
					计算机有很好的记忆力。现在计算机上的程序，很容易存储几百万个像'2. Nf3 Nc6'这样的字符串。这就是为什么计算机不用物理棋盘就能下象棋。它们用数据建模来表示棋盘，你可以编写代码来使用这个模型。 
					这里就可以用到列表和字典。可以用它们对真实世界建模，例如棋盘。作为第一个例子，我们将使用比国际象棋简单一点的游戏：井字棋。
				```
				-	井字棋盘
					-	井字棋盘看起来像一个大的井字符号（#） ，有 9 个空格，可以包含 X、O 或空。要用字典表示棋盘，可以为每个空格分配一个字符串键。ticTacToe.py
			-	小结
				```
					在本章中，你学习了字典的所有相关知识。列表和字典是这样的值，它们可以包含多个值，包括其他列表和字典。字典是有用的，因为你可以把一些项（键）映射到另一些项（值） ，它不像列表，只包含一系列有序的值。字典中的值是通过方括号访问的，像列表一样。字典不是只能使用整数下标，而是可以用各种数据类型作为键：整型、浮点型、字符串或元组。通过将程序中的值组织成数据结构，你可以创建真实世界事物的模型。井字棋盘就是这样一个例子。
				```

		*  集合
		*	类型转换
			|类型转换函数	|转换路径
			|float(string)	|字符串 -> 浮点值
			|int(string)		|字符串 -> 整数值
			|str(integer)		|整数值 -> 字符串
			|str(float)		|浮点值 -> 字符串

	###  运算符
		*  运算，是计算机最基本的功能，我们先来学习一下运算符。运算符用于执行程序的运算，我们这里先学习最简单的几种：「算术运算符」、「比较运算符」、「赋值运算符」、「逻辑运算符」
		*  算术运算符
			-	数学操作符的操作顺序（也称为“优先级” ）与数学中类似。**操作符首先求值，接下来是*、/、//和%操作符，从左到右。+和-操作符最后求值，也是从左到右。如果需要，可以用括号来改变通常的优先级。
			-	+在用于两个字符串时，它将字符串连接起来，成为“字符串连接”操作符
			-	但*操作符用于一个字符串值和一个整型值时，它变成了“字符串复制”操作符。操作符只能用于两个数字（作为乘法） ，或一个字符串和一个整型（作为字符串复制操作符）
			|运算符|名称    |描述
			|  +       |  加     |两个对象相加
			|  -       |  减     |得到负数或是一个数减去另一个数
			|  *       |  成     |两个数相乘或是返回一个被重复若干次的字符串
			|  /       |  除     |x 除以 y
			|  %      |  取模 |返回除法的余数
			|  **     |  幂     |返回 x 的 y 次幂(指数)
			|  //     |取整除|返回商的整数部分（向下取整）
		*  比较运算符（返回结果为布尔值）
			|运算符	  |描述
			|    ==    |等于：比较对象是否相等
			|    !=	     |不等于：比较两个对象是否不相等
			|    >      |大于：返回 x 是否大于 y
			|    <	     |小于：返回 x 是否小于 y
			|    >=    |大于等于：返回 x 是否大于等于 y
			|    <=    |小于等于：返回 x 是否小于等于 y
		*  赋值运算符
			|运算符	|描述	                    |实例
			|    =     |赋值运算符	            |c = a + b ：将 a + b 的运算结果赋值为 c
			|    +=	|加法赋值运算符	    |c += a ：等效于 c = c + a
			|    -=	|减法赋值运算符	    |c -= a ：等效于 c = c - a
			|    *=	|乘法赋值运算符	    |c *= a ：等效于 c = c * a
			|    /=	|除法赋值运算符	    |c /= a ：等效于 c = c / a
			|    %=	|取模赋值运算符	    |c %= a ：等效于 c = c % a
			|    **=	|幂赋值运算符	        |c **= a ：等效于 c = c ** a
			|    //=	|取整除赋值运算符	|c //= a ：等效于 c = c // a
		*  逻辑运算符(布尔操作符)
			-  如果计算机只有计算功能，那它顶多是一个计算器；而我们今天使用的计算机之所以智能、可编程，最重要的原因是：它能够进行 逻辑处理。
			-	3 个布尔操作符（and、or 和 not）用于比较布尔值。像比较操作符一样，它们将这些表达式求值为一个布尔值
			-	二元布尔操作符 (and,or)
				*	and 和 or 操作符总是接受两个布尔值（或表达式） ，所以它们被认为是“二元”操作符。如果两个布尔值都为 True，and 操作符就将表达式求值为 True，否则求值为 False。
			-	not操作符
				*	和 and 和 or 不同，not 操作符只作用于一个布尔值（或表达式） 。not 操作符求值为相反的布尔值
			-  逻辑运算符，即高中数学中的「 且、或、非 」，Python 中用 and、or、not 表示这三种逻辑。
			|运算符            	| 逻辑表达式 |结果
			|and（逻辑与）	| a and b	    |当 a、b 都为 True 时，返回 True；否则返回 False
			|or（逻辑或）	| a or b	        |当 a、b 任意一个为 True，就返回 True
			|not（逻辑非）	| not a	        |当 a 为 True 时，返回 False；反之亦然
			```
				对于逻辑 与，或，非，我们使用 and，or，not 这几个关键字。

				逻辑运算符 and 和 or 也称作短路运算符：它们的参数从左向右解析，一旦结果可以确定就停止。例如，如果 A 和 C 为真而 B 为假，A and B and C 不会解析 C 。作用于一个普通的非逻辑值时，短路运算符的返回值通常是能够最先确定结果的那个操作数。

				关系运算可以通过逻辑运算符 and 和 or 组合，比较的结果可以用 not 来取反意。逻辑运算符的优先级又低于关系运算符，在它们之中，not 具有最高的优先级，or 优先级最低，所以 A and not B or C 等于 (A and (notB)) or C。当然，括号也可以用于比较表达式。
			```
			-	**算术操作符一样，布尔操作符也有操作顺序。在所有算术和比较操作符求值后，Python 先求值 not 操作符，然后是 and 操作符，然后是 or 操作符**
		*	简写运算符（增强的赋值操作 ）
			-	x op= expression 为简写运算的语法形式。其等价于 x = x op expression
				```
					# 在对变量赋值时，常常会用到变量本身。例如，将 42 赋给变量 spam 之后，用下面的代码让 spam 的值增加 1：
					# 作为一种快捷方式，可以用增强的赋值操作符+=来完成同样的事
					# 针对+、-、*、/和%操作符，都有增强的赋值操作符，
					>>> a = 12
					>>> a += 13
					>>> a
					25
					>>> a /= 3
					>>> a
					8.333333333333334
					>>> a += (26 * 32)
					>>> a
					840.3333333333334
				``` 
			-	**+=操作符也可以完成字符串和列表的连接， *=操作符可以完成字符串和列表的复制。**


	###  变量
		*  word = 'Hello world', num = 11,word2 = word
	###  注释
		*  注释，可理解为程序的注解、提示，用来帮助他人和自己阅读、理解、编写代码。python 中，# 常被用作写单行注释，# 号后的内容会被忽略，不会被当作代码处理。
	###  流程控制
		*	控制流语句的开始部分通常是“条件” ，接下来是一个代码块，称为“子句” 。
		*	控制流的元素 
			-	条件
				布尔表达式可以看成是条件，它和表达式是一回事。条件总是求值为一个布尔值，True 或False
			-	代码块
				一些代码行可以作为一组，放在“代码块”中。可以根据代码行的缩进，知道代码块的开始和结束
				```
					代码块有 3 条规则。 
					1．缩进增加时，代码块开始。 
					2．代码块可以包含其他代码块。 
					3．缩进减少为零，或减少为外面包围代码块的缩进，代码块就结束了。 
				```
		*	控制流语句 
			-	if ... else...
				```
					if ...:
						...	
					if ... :
						...
					else  ...
					if ...:
						...
					elif ...:
						...
					else ...
				```
			-	真值检测
				```
				#	检测真值的优雅方式是这样的：
				if x:
				    pass

				#	不要像下面这样做：
				if x == True:
				    pass
				```
				```
					“类真”和“类假”的值 
					其他数据类型中的某些值，条件认为它们等价于 True 和 False。在用于条件时，0、0.0 和' '（空字符串）被认为是 False，其他值被认为是 True。例如，请看下面的程序： 
					 
					name = '' 
					while not name: 
					print('Enter your name:') 
					name = input() 
					print('How many guests will you have?') 
					numOfGuests = int(input()) 
					if numOfGuests: 
					print('Be sure to have enough room for all your guests.') 
					print('Done') 
					 
					如果用户输入一个空字符串给 name，那么 while 语句的条件就会是 True ，程序继续要求输入名字。 如果 numOfGuests 不是 0 ， 那么条件就被认为是 True，程序就会为用户打印一条提醒信息。 可以用 not name != ' '代替 not name， 用 numOfGuests != 0 代替 numOfGuests，但使用类真和类假的值会让代码更容易阅读
				```
		*  pass 关键字(跳过当前代码继续运行)
		*  循环结构
			1.  for ... in ...: for 循环 适用于 已知循环次数 的循环，所以后面跟的是次数或区间，到达指定次数就停止。
				```
				for ... in ...:
					...
				for i in range(1,day+1):
					print('你离开的第{}天，想你'.format(i))
				```
			2.  while ...:  while循环(现实生活中，我们往往不知道要循环多少次，才能达成目标。)while 后面跟的是一个条件，只要条件满足，这个循环就会一直进行下去
				利用 while 语句，可以让一个代码块一遍又一遍的执行。只要 while 语句的条件为 True，while 子句中的代码就会执行
				```
				a = 1
				num = 10
				while a <= num:
					print(a)
					a = a+1
				```
		*  break和continue
			**  break  直接跳出当前循环
				```
				#  只打印0,1,2,3,4，当a==5时，满足条件，跳出循环，不再执行
				for a in range(10):
					if a == 5
						break
					print(a)
				```
			**  continue  跳出此轮循环轮次，执行下一轮循环
				```
				# 打印1,2,3,4,6,7,8,9,10，当a==5是跳出此轮循环，继续执行之后的循环
				a = 0
				while a < 10:
					a += 1
					if a == 5
						continue
					print(a)
				```
			**   实际上，只能在 while 和for 循环内部使用 continue 和 break 语句。如果试图在别处使用这些语句，Python 将报错。
		*	用 sys.exit()提前结束程序(因为exit()函数在sys模块中，所以需要先import sys模块)

	###	函数
		*	函数声明(函数定义)
			-	def语句
				```
					def hello():
						print('Hello World!')

					hello()

					#	第一行是 def 语句，它定义了一个名为hello()的函数。def语句之后的代码块是函数体。这段代码在函数调用时执行，而不是在函数第一次定义时执行。 函数之后的 hello()语句行是函数调用。在代码中，函数调用就是函数名后跟上括号，也许在括号之间有一些参数。如果程序执行遇到这些调用，就会跳到函数的第一行，开始执行那里的代码。如果执行到达函数的末尾，就回到调用函数的那行，继续像以前一样向下执行代码。
					#	函数的一个主要目的就是将需要多次执行的代码放在一起
				```
			-	参数
				如果调用 print()或 len()函数， 你会传入一些值， 放在括号之间， 在这里称为 “参数” 。也可以自己定义接收参数的函数。在这个程序的 hello()函数定义中，有一个名为 name 的变元。 “变元”是一个变量，当函数被调用时，参数就存放在其中。关于变元有一件特殊的事情值得注意：**保存在变元中的值，在函数返回后就丢失了。**
				```
					鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这**要求实参的顺序与形参的顺序相同**；也可使用**关键字实参，其中每个实参都由变量名和值组成**；还可使用列表和字典。
				```
				*	传入参数的可修改和不可修改
				*	传递任意参数
					```
						# 形参名*toppings中的星号让Python创建一个名为toppings的空元组， 并将收到的所有值都封装到这个元组中。
						def makePizza(*toppings):
							# do something, like make a pizza
							for topping in toppings:
								print('-' + topping)
						#	如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。 
					```
				*	传递任意关键字实参
					```
						# 有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。
						def buildProfile(first, last, **userinfo):
							profile = {}
							profile['firstName'] = first
							profile['lastName']  = last
							for key, value in userinfo.items():
								profile[key] = value
							return profile
							userProfile = buildProfile('Bob', 'Einsten', location='princeton', field='physics')
							print(userProfile)
					```

			-	关键字参数
				```
					大多数参数是由它们在函数调用中的位置来识别的。 例如， random.randint(1, 10)与 random.randint(10, 1)不同。函数调用 random.randint(1, 10)将返回 1 到 10之间的一个随机整数，因为第一个参数是范围的下界，第二个参数是范围的上界（而random.randint(10, 1)会导致错误） 。
					但是，** “关键字参数”是由函数调用时加在它们前面的关键字来识别的。**关键字参数通常用于可选变元。例如，print()函数有可选的变元end和sep，分别指定在参数末尾打印什么，以及在参数之间打印什么来隔开它们。
				```
			-	返回值(return语句)
				一般来说，函数调用求值的结果，称为函数的“返回值” 。 
				```
					用 def 语句创建函数时，可以用 return 语句指定应该返回什么值。return 语句包含以下部分： 
					  return 关键字； 
					  函数应该返回的值或表达式。 
					如果在 return 语句中使用了表达式，返回值就是该表达式求值的结果。
				```
				```
					None值(NoneType)
					在幕后，对于所有没有 return 语句的函数定义，Python 都会在末尾加上 return None。这类似于 while 或 for 循环隐式地以 continue 语句结尾。而且，如果使用不带值的 return 语句（也就是只有 return 关键字本身） ，那么就返回 None。
				```
		*	作用域
			-	作用域
				```
					在被调用函数内赋值的变元和变量，处于该函数的“局部作用域” 。在所有函数之外赋值的变量，属于“全局作用域” 。处于局部作用域的变量，被称为“局部变量” 。处于全局作用域的变量，被称为“全局变量” 。**一个变量必是其中一种，不能既是局部的又是全局的。 **

					可以将“作用域”看成是变量的容器。当作用域被销毁时，所有保存在该作用域内的变量的值就被丢弃了。只有一个全局作用域，它是在程序开始时创建的。如果程序终止，全局作用域就被销毁，它的所有变量就被丢弃了。否则，下次你运行程序的时候，这些变量就会记住它们上次运行时的值。 
					**一个函数被调用时， 就创建了一个局部作用域。在这个函数内赋值的所有变量，存在于该局部作用域内。**该函数返回时，这个局部作用域就被销毁了，这些变量就丢失了。 下次调用这个函数， 局部变量不会记得该函数上次被调用时它们保存的值。  

					**作用域很重要，理由如下： **
					  全局作用域中的代码不能使用任何局部变量； 
					  但是，局部作用域可以访问全局变量； 
					  一个函数的局部作用域中的代码，不能使用其他局部作用域中的变量。 
					  如果在不同的作用域中，你可以用相同的名字命名不同的变量。也就是说，可以有一个名为 spam 的局部变量，和一个名为 spam 的全局变量。

					Python 有不同的作用域，而不是让所有东西都成全局变量，这是有理由的。这样一来，当特定函数调用中的代码修改变量时，该函数与程序其他部分的交互，只能通过它的参数和返回值。这缩小了可能导致缺陷的代码作用域。如果程序只包含全局变量， 又有一个变量赋值错误的缺陷， 那就很难追踪这个赋值错误发生的位置。它可能在程序的任何地方赋值，而你的程序可能有几百到几千行！但如果缺陷是因为局部变量错误赋值，你就会知道，只有那一个函数中的代码可能产生赋值错误。 
					**虽然在小程序中使用全局变量没有太大问题，但当程序变得越来越大时，依赖全局变量就是一个坏习惯。**
					当程序执行在全局作用域中时，不存在局部作用域，所以不会有任何局部变量。
				```
			-	全局作用域
				+	在所有函数之外赋值的变量，属于“全局作用域” 。
				+	全局变量
					-	处于全局作用域的变量，被称为“全局变量” 。
					-	全局变量可以在局部作用域内使用。
				```
					有 4 条法则，来区分一个变量是处于局部作用域还是全局作用域： 
					1．如果变量在全局作用域中使用（即在所有函数之外） ，它就总是全局变量。 
					2．如果在一个函数中，有针对该变量的 global 语句，它就是全局变量。 
					3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。 
					4．但是，如果该变量没有用在赋值语句中，它就是全局变量。
				```
			-	局部作用域
				+	在被调用函数内赋值的变元和变量，处于该函数的“局部作用域” 。
				+	局部变量
					-	处于局部作用域的变量，被称为“局部变量” 。
					-	局部变量不能在全局作用域内使用 。
					-	 局部作用域不能使用其他局部作用域内的变量。
			```
				# 名称相同的局部变量和全局变量
				# 要想生活简单，就要避免局部变量与全局变量或其他局部变量同名
				# sameName.py

				def spam():
					# wrong
					# Traceback (most recent call last): 
					#   File "C:/test3784.py", line 6, in <module> 
					#     spam() 
					#   File "C:/test3784.py", line 2, in spam 
					#     print(eggs) # ERROR! 
					# UnboundLocalError: local variable 'eggs' referenced before assignment 
					# print(eggs, end = '\n ' + '=' * 10 + '\n')
					#	发生这个错误是因为， Python 看到 spam()函数中有针对 eggs 的赋值语句， 因此认为 eggs 变量是局部变量。 但是因为 print(eggs)的执行在 eggs 赋值之前，局部变量 eggs 并不存在。Python 不会退回到使用全局 eggs 变量

					eggs = 'spam local'
					print(eggs)

				def bacon():
					eggs = 'bacon local'
					print(eggs)
					spam()
					print(eggs)

				eggs = 'global'
				# spam()
				bacon()
				print(eggs)

				在这个程序中， 实际上有 3 个不同的变量， 但令人迷惑的是， 它们都名为 eggs。
				这些变量是： 
				名为 eggs 的变量，存在于 spam()被调用时的局部作用域； 
				名为 eggs 的变量，存在于 bacon()被调用时的局部作用域； 
				名为 eggs 的变量，存在于全局作用域。 
				**因为这 3 个独立的变量都有相同的名字，追踪某一个时刻使用的是哪个变量，
				可能比较麻烦。**这就是应该避免在不同作用域内使用相同变量名的原因。
			```
		*	将函数储存在模块中
			-	函数的优点之一就是可以将代码块和主程序分离。通过给函数指定描述性名称可以让主程序容易理解。还可以将函数储存在被成为模块的独立文件中，再将模块导入到主程序中。**import语句可以在当前运行的程序文件中使用模块中的代码。所有的import语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。**
			-	导入模块
				```
					# 要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。
					# 创建一个包含makePizza函数的模块pizza.py
					# pizza.py
					def makePizza(size, *toppings):
						print('Making a ' + str(size) + '-inch pizza with following topping:')
						for topping in toppings:
							print('- ' + topping)
				```
				1.	导入整个模块
					*	编写一条import语句并在其中指定模块名，就可以在程序中使用该模块下的所有函数。如果使用import语句导入了名为moduleName.py的整个模块，就可以使用moduleName.functionName()，来使用其中的一个函数。
					*	导入多个模块时可以在每个模块名之后加上,(逗号)来隔开每个模块
					```
						# 然后在pizza.py所在的目录下新建一个名为makingPizza.py的文件，在这个文件中导入刚创建的pizza.py模块，在调用两次makePizza.py函数
						# makingPizza.py
						import pizza.py

						pizza.makePizza(17, 'onion', 'meat', 'extra cheese')
						pizza.makePizza(12, 'mushroom', 'green peppers')
						"""
							Python读取这个文件时，代码行import pizza让Python打开文件pizza.py，并将其中的所有函数都复制到这个程序中。
							你看不到复制的代码，因为这个程序运行时，Python在幕后复制这些代码。
							你只需知道，在making_pizzas.py中，可以使用pizza.py中定义的所有函数。 
							要调用被导入的模块中的函数， 可指定导入的模块的名称pizza和函数名make_pizza()， 并用句点分隔它们（见Ø） 。
						"""
					```
				2.	导入特定的函数
					*	from moduleName import functionName
					*	导入多个函数时，可以在每个函数之后加上,(逗号)来隔开每个函数
					*	from moduleName import * (导入模块中的所有函数)**(不推荐使用这种方式导入函数，会覆盖同名函数和变量)**
					*	使用这种方式导入模块时，可以直接使用函数名调用(makePizza())，无需再使用Module.functionName()来调用
				3.	使用as关键字给函数指定别名
					*	from moduleName import functionName as fn，使用的时候直接使用别名调用该函数就可以了。fn() 
				4.	使用as关键字给模块指定别名
					*	import moduleName as mn，使用的时候直接使用别名调用该模块就可以了。mn.functionName()
		*	异常处理
			-	错误可以由 try 和 except 语句来处理。那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。可以将前面除数为零的代码放在一个 try 子句中，让 except 子句包含代码，来处理该错误发生时应该做的事
				```
					函数作为“黑盒” 
					通常，对于一个函数，你要知道的就是它的输入值（变元）和输出值。你并非总是需要加重自己的负担，弄清楚函数的代码实际是怎样工作的。如果以这种高层的方式来思考函数，通常大家会说，你将该函数看成是一个黑盒。 这个思想是现代编程的基础。本书后面的章节将向你展示一些模块，其中的函数是由其他人编写的。尽管你在好奇的时候也可以看一看源代码，但为了能使用它们，你并不需要知道它们是如何工作的。而且，因为鼓励在编写函数时不使用全局变量，你通常也不必担心函数的代码会与程序的其他部分发生交叉影响。
				```
			-	如果在 try 子句中的代码导致一个错误，程序执行就立即转到 except 子句的代码。在运行那些代码之后，执行照常继续。但是一旦执行跳到 except 子句的代码，就不会回到 try 子句。它会继续照常向下执行。(try语句的位置决定程序运行中断的位置)

		*	方法
			-	方法和函数是一回事，只是它是调用在一个值上。例如，如果一个列表值存储在 spam 中，你可以在这个列表上调用index()列表方法（稍后我会解释），就像spam.index('hello')一样。方法部分跟在这个值后面，以一个句点分隔。 每种数据类型都有它自己的一组方法。 例如， **列表数据类型有一些有用的方法，用来查找、添加、删除或操作列表中的值。**
			-	**方法属于单个数据类型。**append()和 insert()方法是列表方法，只能在列表上调用，不能在其他值上调用，例如字符串和整型。在交互式环境中输入以下代码，注意产生的 AttributeError 错误信息
			
	###	类
		*	面向对象编程是最有效的软件编写方法之一。
			```
				在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。 
				根据类来创建对象被称为实例化， 这让你能够使用类的实例。 在本章中， 你将编写一些类并创建其实例。你将指定可在实例中存储什么信息， 定义可对这些实例执行哪些操作。 你还将编写一些类来扩展既有类的功能，让相似的类能够高效地共享代码。你将把自己编写的类存储在模块中，并在自己的程序文件中导入其他程序员编写的类。 
			```
		*	创建和使用类
			-	创建类
				*	使用class关键字定义类
				*	在python中，首字母大写的名字指的是类，这个类定义中的括号是空的，因为我们要从空白中创建这个类。
				*	方法__init__()，类中的函数通称为方法，就目前而言，唯一重要的区别就在于调用方法的方式。__init__()是一个特殊的方法，当根据Dog()对象创建新实例时，就会自动运行它。在这个方法的名称中，开头和末尾都有两个下划线，这是一种约定，旨在避免Python默认方法与其他的普通方法名称发生冲突。我们将方法__init__()定义成了包含三个形参：self、name和age。在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面。为何必须在方法定义中包含形参self呢？因为Python调用这个__init__()方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog实例时，Python将调用Dog类的方法__init__()。我们将通过实参向Dog()传递名字和年龄；self会自动传递，因此我们不需要传递它。每当我们根据Dog类创建实例时，都只需给后两个形参（name和age）提供值。
				*	以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。self.name=name获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。self.age = age的作用与此类似。像这样可通过实例访问的变量称为属性。
				*	Dog类还定义了另外两个方法：sit()和roll_over()。由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参self。
				```
					# 由于大多数小狗都具备上述两项信息（名字和年龄）和两种行为（蹲下和打滚） ，我们的Dog类将包含它们。这个类让Python知道如何创建表示小狗的对象。

					# dog.py
					class Dog():

						def __init__(self, name, age):
							#	初始化属性name和age
							self.name = name
							self.age = age
						# 小狗被命令时坐下
						def sit(self):
							print(self.name.title() + ' is now sitting.')
						# 小狗被命令时打滚
						def rollOver(self):
							print(self.name.title() + ' is now rolled over.')
				```
			-	根据类创建实例
				*	可将类视为有关如何创建实例的说明。Dog()类是一系列的说明，让Python知道如何创建表示特定小狗的实例。
					```
						class Dog():
							--snip--

						myDog = Dog('willie', 6)

						print('My dog is ' + myDog.name.title() + '.')
						print('My dog is ' + str(myDog.age) + 'years old.')

						myDog.sit()
						myDog.rollover()
						"""
							这里使用的是前一个示例中编写的Dog类。在处，我们让Python创建一条名字为'willie'、年龄为6的小狗。遇到这行代码时，Python使用实参'willie'和6调用Dog类中的方法__init__()。方法__init__()创建一个表示特定小狗的示例， 并使用我们提供的值来设置属性name和age。 方法__init__()并未显式地包含return语句，但Python自动返回一个表示这条小狗的实例。我们将这个实例存储在变量my_dog中。 在这里， 命名约定很有用：我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog）指的是根据类创建的实例。 
						"""
					```
				*	访问属性
					-	要访问实例的属性。可使用句点表示法。
				*	调用方法
					-	根据Dog()类创建实例后，就可以使用句点表示法来调用Dog类中定义的任何方法。
				*	创建多个实例
					```
						myDog = Dog('willew', 6)
						yourDog = Dog('lucy', 3)
						dogMikuya = Dog('mikuya', 2)

						myDog.name
						yourDog,name
						dogMikuya.sit()
						dogMikuya.rollOver()
						# 每条小狗都是一个独立的实例，有自己的一组属性，能够执行相同的操作.就算我们给第二条小狗指定同样的名字和年龄，Python依然会根据Dog类创建另一个实例。你可按需求根据一个类创建任意数量的实例，条件是将每个实例都**存储在不同的变量中，或占用列表或字典的不同位置。 **
					```
			-	使用类和实例
				*	你可以使用类来模拟现实世界中的很多情景。类编写好后，你的大部分时间都将花在使用根据类创建的实例上。 你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。
				*	给属性设置初始值
					-	在__init__()方法中指定。self.property = 0
				*	修改属性的值
					-	直接通过实例进行修改。isstance.property = 123
					-	通过方法进行设置(推荐)
					-	通过方法进行递增					
		*	继承
			```
				编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。
			```
			-	创建子类时，父类必须包含在当前文件中，且位于子类前面。定义子类时， 必须在括号内指定父类的名称。
			-	子类__init__()方法，子类的__init()__方法需要使用super().__init()__。super()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法__init__()，让ElectricCar实例包含父类的所有属性。父类也称为超类（superclass） ，名称super因此而得名
			-	重写父类的方法，子类方法与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。 
			-	将实例用作属性
				```
					使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。 
				```
		*	导入类
			```
				随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python允许你将类存储在模块中，然后在主程序中导入所需的模块。
			```
			-	导入单个类
				```
					# Car类被存放在car.py模块中
					from car import Car

					myCar = Car('tesla', 'Model S', 2017)
					"""
						导入类是一种有效的编程方式。如果在这个程序中包含了整个Car类，它该有多长呀！
						通过将这个类移到一个模块中，并导入该模块，你依然可以使用其所有功能，但主程序文件变得整洁而易于阅读
						这还能让你将大部分逻辑存储在独立的文件中；确定类像你希望的那样工作后，你就可以不管这些文件，而专注于主程序的高级逻辑了。
					"""
				```
			-	在一个模块中存储多个类
			-	在一个模块中导入多个类
				*	用逗号分隔开需要导入的类，from car import Car, ElectricCar
			-	导入整个模块(推荐)
				*	导入整个模块之后，用模块句点访问需要的类。这种导入方式在创建类实例的代码中都包含模块名，因此不会和当前文件使用的任何名称冲突，同时也是代码易于阅读。
					```
						import car
						myCar = car.Car()
						myElectricCar = car.ElectriCar()
					```
			-	导入模块中的所有类(不推荐)
				*	from moduleName import *
			-	在一个模块中导入另一个模块
			-	自定义工作流程
			-	Python标准库
				```
					Python标准库是一组模块， 安装的Python都包含它。 你现在对类的工作原理已有大致的了解，可以开始使用其他程序员编写好的模块了。可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的import语句。下面来看模块collections中的一个类——OrderedDict。
				```
		*	类编码风格 
			```
				 你必须熟悉有些与类相关的编码风格问题，在你编写的程序较复杂时尤其如此。 类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。 
				对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。 可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。 
				需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import语句，再添加一个空行， 然后编写导入你自己编写的模块的import语句。在包含多条import语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何方。 
			```
	###  python内置函数
		*  print() -- 打印函数(打印变量，字符串，整型，数据)
			-	tips:
				1.	默认情况下，print() 除了打印你提供的字符串之外，还会打印一个换行符，所以每调用一次 print() 就会换一次行，如同上面一样。
					你可以通过 print() 的另一个参数 end 来替换这个换行符
				2.	字符串若是乘上整数 n，将返回由 n 个此字符串拼接起来的新字符串。print('-' * 50)
		*  input() -- 输入函数(记录用户交互的输入，执行之后如果没有输入，程序回一直卡住)
		*  format()  -- 格式化函数(插入数据，数字格式化)
			-  exp：
				1.	print('我叫{}，今年{}岁了。'.format(name,age))
				2.	print('{:.3f}'.format(3.141592653))
				3.	print("{:5d}".format(i * n), end=' ')
		*  int() -- 转换为整数(传入值只能为数字和纯数字的字符串，如果传入的值为浮点型，则保留整数部分，如果为a,bac，则不行)
			- tips:
				1.	需要对浮点数进行取整运算，也可以用 int()函数。
					```
						>>>int(7.7)
						8
					```
		*	str() -- 转换为字符串
		*	float() -- 转换为浮点数
		*	list() -- 转换成为列表
		*	tuple() -- 转换成为元组
		*  range() -- 范围函数(返回一个0到n-1的数字列表)
			-  exp：
				1.	range(n) -- 返回一个0到n-1的数字列表
				2.	range(a,b) -- 返回一个a到b的数字列表(包头不包尾，要取到b则为range(a,b+1))
				3.	range(a,b,c) -- 返回一个以c为间隔从a到b的数字列表
				4.	range(9,-2,-2)
		*	divmod() -- 返回一个元组
			-	exp:
				1.	divmod(num1, num2) 返回一个元组，这个元组包含两个值，第一个是 num1 和 num2 相整除得到的值，第二个是 num1 和 num2 求余得到的值
		*	len() -- 返回对象的长度（元素个数），实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）
		*	round() -- round(number[, ndigits]) 返回 number 舍入到小数点后 ndigits 位精度的值。 如果 ndigits 被省略或为 None，则返回最接近输入值的整数。
		*	abs() -- 返回数字的绝对值，参数可为整型、浮点型、复数，当为复数时返回复数的模
		*	type() -- 返回传入变量的类型

	### python模块
		*	random  --  生成随机数
		*	pprint  -- 格式化打印字典
		*	pyperclip  --  拷贝粘贴字符串 
			-	pyperclip 模块有 copy()和 paste()函数，可以向计算机的剪贴板发送文本，或从它接收文本。将程序的输出发送到剪贴板，使它很容易粘贴到邮件、文字处理程序或其他软件中。pyperclip 模块不是 Python 自带的。要安装它，请遵从附录 A 中安装第三方模块的指南。
		*	re  -- 正则表达式

	### 运行程序
		*	第一行
			```
				所有 Python 程序的第一行应该是#!行， 它告诉计算机你想让 Python 来执行这个程序。该行以#!开始，但剩下的内容取决于操作系统。 
				  在 Windows 上，第一行是 #! python3。 
				  在 OS X，第一行是 #! /usr/bin/env python3。 
				  在 Linux 上，第一行是 #! /usr/bin/python3。 
				没有#!行，你也能从 IDLE 运行 Python 脚本，但从命令行运行它们就需要这一行。
			```
		*	在 Windows 上运行 Python 程序
			```
				在 Windows 上，Python3.4 的解释程序位于 C:\Python34\python.exe。或者，方便的 py.exe 程序将读取.py 文件源代码顶部的#!行， 并针对该脚本运行相应的 Python版本。如果计算机上安装了多个版本的 Python，py.exe 程序确保运行正确版本的Python 程序。 
				为了方便运行你的 Python 程序，可以创建一个.BAT 批处理文件，用 py.exe 来运行 Python 程序。要创建一个批处理文件，就创建一个新的文本文件，包含一行内容，类似下面这样：
				@py.exe C:\path\to\your\pythonScript.py %* 
				用你自己的程序的绝对路径替换该路径，将这个文件以.bat 文件扩展名保存（例如，pythonScript.bat）。这个处理文件将使你不必在每次运行时，都输入Python程序完整的绝对路径。我建议将所有的批处理文件和.py 文件放在一个文件夹中，如C:\MyPythonScripts 或 C:\Users\YourName\PythonScripts。 
			```
		*	在 OS X 和 Linux 上运行 Python 程序 
			```
				在 OS X 上， 选择 Applications►Utilities►Terminal 将弹出一个终端窗口。 终端窗口让你用纯文本在计算机上输入命令，而不是通过图形界面点击。要在 Ubuntu Linux 上打开终端窗口，就按Win（或Super）键，调出Dash 并输入Terminal。 

				终端窗口将从你的用户账户的主文件夹开始。 如果我的用户名是 sweigart， OS X上主文件夹在/Users/asweigart，Linux 上在/home/asweigart。波浪纯字符（~）是主文件夹的快捷方式，所以你可以输入 cd ~切换到主文件夹。也可以使用 cd 命令，将当前工作目录改变到任何其他目录。在 OS X 和 Linux 上，pwd 命令将打印当前工作目录。 

				为了运行 Python 程序，将你的.py 文件保存到你的主文件夹。然后，更改.py 文件的权限，运行chmod +x pythonScript.py，使之成为可执行文件。文件权限超出了本书的范围，但如果你想在终端窗口运行程序，就需要对 Python 文件运行此命令。这样做之后，当你打开一个终端窗口，输入./pythonScript.py，就能运行该脚本。脚本顶部的#!行会告诉操作系统，在哪里可以找到 Python 解释器。 
			```
		*	运行 Python 程序时禁用断言
			```
				你可以禁用 Python 程序中的 assert 语句，从而稍稍提高性能。从终端窗口运行Python 时，在 python 或 python3 之后和.py 文件之前加上-O 开关。这将运行程序的优化版本，跳过断言检查。
			```
		
	###	模糊匹配与正则表达式(regex)
		*	正则表达式(regex)
			-	你可能熟悉文本查找， 即按下Ctrl-F， 输入你要查找的词。 “正则表达式”更进一步，它们让你指定要查找的“模式” 。
			-	正则表达式，简称为 regex，是文本模式的描述方法。
				```
					例如，\d 是一个正则表达式，表示一位数字字符，即任何一位 0 到 9 的数字。Python 使用正则表达式\d\d\d-\d\d\d-\d\d\d\d，来匹配前面 isPhoneNumber()函数匹配的同样文本：3 个数字、一个短横线、3 个数字、一个短横线、4 个数字。所有其他字符串都不能匹配\d\d\d-\d\d\d-\d\d\d\d 正则表达式。 
					但正则表达式可以复杂得多。例如，在一个模式后加上花括号包围的 3（{3}） ，就是说， “匹配这个模式 3 次” 。所以较短的正则表达式\d{3}-\d{3}-\d{4}，也匹配正确的电话号码格式。
					'\d' -- 匹配0到9的数字，\d{3} -- 匹配这个模式三次
					'\d\d\d-\d\d\d-\d\d\d\d' == '\d{3}-\d{3}-\d{4}'
				```
			-	创建正则表达式
				*	Python 中所有正则表达式的函数都在 re 模块中。在交互式环境中输入以下代码，导入该模块：import re
				*	向 re.compile()传入一个字符串值，表示正则表达式，它将返回一个 Regex 模式对象（或者就简称为 Regex 对象） 。 
				*	正则表达式使用方法
					1.	导入re模块。
					2.	创建正则表达式对象。
					3.	传入字符串到正则表达式对象对应的方法。
					4.	对返回的结果调用对应的方法。 
						```
							import re
							regexObject = re.compile(r'regexRule')
							regexResult = regexObject.search(string)
							regrxResult.group()

							1.	import re 导入正则表达式模块。 
							2.	用 re.compile()函数创建一个 Regex 对象（记得使用原始字符串） 。 
							3.	向 Regex 对象的 search()方法传入想查找的字符串。 它返回一个 Match 对象。  
							4.	调用 Match 对象的 group()方法，返回实际匹配文本的字符串。
						```
						```
							在字符串的第一个引号之前加上 r，可以将该字符串标记为原始字符串，它不包括转义字符.
							正则表达式常常使用倒斜杠， 向 re.compile()函数传入原始字符串就很方便 ， 而 不 是 输 入 额 外 得 到 斜 杠 。
							输 入 r'\d\d\d-\d\d\d-\d\d\d\d' ， 比 输 入'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d'要容易得多。 
						```
				*	利用括号()分组
					-	re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d)')，
						```
							假定想要将区号从电话号码中分离。添加括号将在正则表达式中创建“分组” ：(\d\d\d)-(\d\d\d-\d\d\d\d)。然后可以使用 group()匹配对象方法，从一个分组中获取匹配的文本
							regexObject = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')
							regexResult = regexObject.search(str)
							regexResult.group(1)

							正则表达式字符串中的第一对括号是第 1 组。第二对括号是第 2 组。向 group()匹配对象方法传入整数 1 或 2，就可以取得匹配文本的不同部分。向 group()方法传入 0 或不传入参数，将返回整个匹配的文本。
							如果想要一次就获取所有的分组，请使用groups()方法，注意函数名的复数形式
							因为 mo.groups()返回多个值的元组，所以你可以使用多重复制的技巧，每个值赋给一个独立的变量，就像前面的代码行：areaCode, mainNumber = mo.groups()。 
						```
						```
							括号在正则表达式中有特殊的含义，但是如果你需要在文本中匹配括号，怎么办？例如，你要匹配的电话号码，可能将区号放在一对括号中。在这种情况下，就需要用倒斜杠对(和)进行字符转义。
							phoneNumRegex = re.compile(r'(\(\d\d\d\)) (\d\d\d-\d\d\d\d)') 
							传递给 re.compile()的原始字符串中，\(和\)转义字符将匹配实际的括号字符。 
						```
				*	利用管道(|)匹配多个分组
					-	字符'|'称为管道。希望匹配许多表达式中的一个时，就可以使用它。
						```
							字符|称为“管道” 。希望匹配许多表达式中的一个时，就可以使用它。例如，
							正则表达式 r'Batman|Tina Fey'将匹配'Batman'或'Tina Fey'。 
							如果 Batman 和 Tina Fey 都出现在被查找的字符串中， 第一次出现的匹配文本，
							将作为 Match 对象返回。在交互式环境中输入以下代码
							>>> heroRegex = re.compile(r'Batman|Tina Fey')
							>>> regexResult = heroRegex.search('Batman and Tina Fey')
							>>> regexResult.group()
							'Batman'
							>>> regexResult = heroRegex.search('Tina Fey and Batman')
							>>> regexResult.group()
							'Tina Fey'
							利用 findall()方法，可以找到“所有”匹配的地方。
						```
					-	也可以使用管道来匹配多个模式中的一个，作为正则表达式的一部分。如果需要匹配真正的管道字符，就用倒斜杠转义，即\|。
						```
							>>> regexObj = re.compile(r'Bat(man|mobile|coper|bat)')
							>>> regexResult = regexOb.search('Batmobile lost a wheel.')
							>>> regexResult = regexObj.search('Batmobile lost a wheel.')
							>>> regexResult.group()
							'Batmobile'
							>>> regexResult.group(1)
							'mobile'
							>>> regexResult.group(0)
							'Batmobile'
						```
				*	用问号(?)实现可选匹配
					-	字符?表明它前面的分组在这个模式中是可选的。你可以认为?是在说， “匹配这个问号之前的分组零次或一次” 。 如果需要匹配真正的问号字符，就使用转义字符\?。
						```
							有时候，想匹配的模式是可选的。就是说，不论这段文本在不在，正则表达式都会认为匹配。
							>>> regexRe = re.compile(r'Bat(wo)?man')
							>>> regexResult = regexRe.search('Batwa and Batman and Batwoman and woman')
							>>> regexResult.groups()
							(None,)
							>>> regexResult.group()
							'Batman'
							>>> regexResult = regexRe.search('The adventures fo Batwoman')
							>>> regexResult.group()
							'Batwoman'
							>>> regexResult = regexRe.search('Batwa and Batwoman and Batman and woman')
							>>> regexResult.groups()
							('wo',)
							>>> regexResult.group()
							'Batwoman'
							>>> regexResult.group(1)
							'wo'
							>>> regexResult.group(0)
							'Batwoman'
							regexObj = re.compile(r'(\d\d\d-)?(\d\d\d-\d\d\d\d)')
						```
				*	用星号(*)匹配零次或多次
					-	*（称为星号）意味着“匹配零次或多次” ，即星号之前的分组，可以在文本中出现任意次。 它可以完全不存在， 或一次又一次地重复。 如果需要匹配真正的星号字符，就在正则表达式的星号字符前加上倒斜杠，即\*。 
						```
							#	对于'Batman'，正则表达式的(wo)*部分匹配 wo 的零个实例。
							#>>> regexObj = re.compile(r'Bat(wo)*?man')
							>>> regexObj = re.compile(r'Bat(wo)*man')
							>>> regexRe = regexObj.search('The adventure of Batman')
							>>> regexRe.group()
							'Batman'
							>>> regexRe = regexObj.search('The adventure of Batwowowowoman')
							>>> regexRe.group()
							'Batwowowowoman'
						```
				*	用加号匹配一次或多次
					-	*意味着“匹配零次或多次” ，+（加号）则意味着“匹配一次或多次”。星号不要求分组出现在匹配的字符串中，但加号不同，加号前面的分组必须“至少出现一次”。这不是可选的。如果需要匹配真正的加号字符，在加号前面加上倒斜杠实现转义：\+。 
						```
							#	正则表达式 Bat(wo)+man 不会匹配字符串'The Adventures of Batman'， 因为加号要求 wo 至少出现一次。
							>>> regexObj = re.compile(r'Bat(wo)+man')
							>>> regexRe = regexObj.search('The adventures of Batman')
							>>> regexRe.group()
							Traceback (most recent call last):
							  File "<console>", line 1, in <module>
							AttributeError: 'NoneType' object has no attribute 'group'
							>>> regexRe = regexObj.search('The adventures of Batwowowoman')
							>>> regexRe.group()
							'Batwowowoman'
							>>> regexRe = regexObj.search('The adventures of Batwoman')
							>>> regexRe.group()
							'Batwoman'
						```
				*	用花括号{}匹配特定次数
					-	如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字。 例如， 正则表达式(Ha){3}将匹配字符串'HaHaHa'， 但不会匹配'HaHa'，因为后者只重复了(Ha)分组两次。
					-	除了一个数字，还可以指定一个范围，即在花括号中写下一个最小值、一个逗号和一个最大值。 例如， 正则表达式(Ha){3,5}将匹配'HaHaHa'、 'HaHaHaHa'和'HaHaHaHaHa'。 也可以不写花括号中的第一个或第二个数字，不限定最小值或最大值。(Ha){3,}将匹配 3 次或更多次实例，(Ha){,5}将匹配 0 到 5 次实例。
						```
							(Ha){3} 
							(Ha)(Ha)(Ha)
							(Ha){2,5}
							(Ha)(Ha)|(Ha)(Ha)(Ha)|(Ha)(Ha)(Ha)(Ha)|(Ha)(Ha)(Ha)(Ha)(Ha)

							>>> helloRegex = re.compile(r'(Ha){3}')
							>>> helloRe = helloRegex.search('HaHaHaHaHaHa')
							>>> helloRe.group()
							'HaHaHa'
							>>> helloRe.groups()
							('Ha',)
							>>> helloRe = helloRegex.search('Ha')
							>>> helloRe.groups()
							Traceback (most recent call last):
							  File "<console>", line 1, in <module>
							AttributeError: 'NoneType' object has no attribute 'groups'
							>>> helloRe.group()
							Traceback (most recent call last):
							  File "<console>", line 1, in <module>
							AttributeError: 'NoneType' object has no attribute 'group'
							>>> helloRe == None
							True
							>>> regexObj = re.compile(r'(Ha){3,5}')
							>>> regexRe = regexObj.search('HaHaHaHaHaHa')
							>>> regexRe.group()
							'HaHaHaHaHa'

						```
				*	贪心和非贪心匹配
					-	Python 的正则表达式默认是“贪心”的，这表示在有二义的情况下，它们会尽可能匹配最长的字符串。花括号的“非贪心”版本匹配尽可能最短的字符串，即在结束的花括号后跟着一个问号。
						```
							>>> regexObj = re.compile(r'(Ha){3,5}')
							>>> regexRe = regexObj.search('HaHaHaHaHaHa')
							>>> regexRe.group()
							'HaHaHaHaHa'
							>>> regexObj = re.compile(r'(Ha){3,5}?')
							>>> regexRe = regexObj.search('HaHaHaHaHaHaHa')
							>>> regexRe.group()
							'HaHaHa'
							请注意，问号在正则表达式中可能有两种含义：声明非贪心匹配或表示可选的分组。这两种含义是完全无关的。
						```
			-	字符分类
				*	在前面电话号码正则表达式的例子中，你知道\d 可以代表任何数字。也就是说，\d是正则表达式(0|1|2|3|4|5|6|7|8|9)的缩写。有许多这样的“缩写字符分类” 。
					|	缩写字符分类	|	 表示 
					|			\d 			|	0 到 9 的任何数字 
					|			\D 			|	除 0 到 9 的数字以外的任何字符
					|			\w 			|	任何字母、数字或下划线字符（可以认为是匹配“单词”字符） 
					|			\W 			|	除字母、数字和下划线以外的任何字符 
					|			\s 			|	空格、制表符或换行符（可以认为是匹配“空白”字符） 
					|			\S 			|	除空格、制表符和换行符以外的任何字符  
				*	字符分类对于缩短正则表达式很有用。字符分类[0-5]只匹配数字 0 到 5，这比输入(0|1|2|3|4|5)要短很多。
					```
						#	'\d+' 匹配0~9的一个或者多个数字，‘\s' 匹配空白字符，'\w+' 匹配一个或者多个单词字符
						#	 findall()方法将返回所有匹配该正则表达式的字符串，放在一个列表中。
						>>> xmasRegex = re.compile(r'\d+\s\w+') 
						>>> xmasRegex.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge') 
						['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge'] 
					```
				*	建立自己的字符分类
					-	用方括号定义自己的字符类型。
						```
							有时候你想匹配一组字符，但缩写的字符分类（\d、\w、\s 等）太宽泛。例如，字符分类[aeiouAEIOU]将匹配所有元音字符，不论大小写。
							>>> regexObj = re.compile(r'[aeiouAEIOU]')
							>>> regexObj.findall('RoboCop eats baby food. BABY FOOD.')['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']
						```
					-	可使用短横表示字母或者数字的范围。如，字符分类[a-zA-Z0-9]将匹配所有的大小写字母和数字。
					-	在方括号内，普通的正则表达式符号不会被解释。这意味着，你不需要前面加上倒斜杠转义 . 、* 、?或()字符。例如，字符分类将匹配数字 0 到 5 和一个句点。你不需要将它写成[0-5\.]。 
					-	通过在字符分类的左方括号后加上一个插入字符(^)，就可以得到"非字符类"，非字符类将匹配不在这个这个字符类中的所有字符。
						```
							现在，不是匹配所有元音字符，而是匹配所有非元音字符。
							regexObj = re.compile(r'[^aeiouAEIOU]')
							>>> regexObj.findall('Robocap eats baby food.BABY FOOD.')
							['R', 'b', 'c', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', 'B', 'B', 'Y', ' ', 'F', 'D', '.']
						```
				*	插入字符和美元字符
					-	在正则表达式的开始处使用插入符号（^），表明匹配必须发生在被查找文本开始处。类似地，可以再正则表达式的末尾加上美元符号（$） ，表示该字符串必须以这个正则表达式的模式结束。可以同时使用^和$，表明整个字符串必须匹配该模式，也就是说，只匹配该字符串的某个子集是不够的。
						```
						>>> regexObj = re.compile(r'^Hello')
						>>> regexObj.search('Hello World.')
						<re.Match object; span=(0, 5), match='Hello'>
						>>> regexRe = regexObj.search('Hello there,Mr.Hellow')
						>>> regexRe.group()
						'Hello'
						>>> regexObj.findall('Hello there,Mr.Hellow.')
						['Hello']
						>>> regexObj.findall('Hellow.')
						['Hello']

						>>> beginsWithHello = re.compile(r'^Hello') 
						>>> beginsWithHello.search('Hello world!') 
						<_sre.SRE_Match object; span=(0, 5), match='Hello'> 
						>>> beginsWithHello.search('He said hello.') == None 
						True 
						```
					-	正则表达式r'\d$'，匹配以数字0~9开始和结束的字符串。
						```
							>>> regexObj = re.compile(r'\d$')
							>>> regexRe = regexObj.search('I am 42 years old.')
							>>> regexRe.group()
							Traceback (most recent call last):
							  File "<console>", line 1, in <module>
							AttributeError: 'NoneType' object has no attribute 'group'
							>>> regexObj.search('Your number is 43')
							<re.Match object; span=(16, 17), match='3'>
							>>> regexRe = regexObj.search('Your number is 42')
							>>> regexRe.group()
							'2'
							>>> endsWithNumber = re.compile(r'\d$') 
							>>> endsWithNumber.search('Your number is 42') 
							<_sre.SRE_Match object; span=(16, 17), match='2'> 
							>>> endsWithNumber.search('Your number is forty two.') == None 
							True
						```
					-	正则表达式 r'^\d+$'匹配从开始到结束都是数字的字符串。
						```
							>>> wholeStringIsNum = re.compile(r'^\d+$') 
							>>> wholeStringIsNum.search('1234567890') 
							<_sre.SRE_Match object; span=(0, 10), match='1234567890'> 
							>>> wholeStringIsNum.search('12345xyz67890') == None 
							True 
							>>> wholeStringIsNum.search('12 34567890') == None 
							True 
							#	前面交互式脚本例子中的最后两次search()调用表明，如果使用了^和$，那么整个字符串必须匹配该正则表达式。
							>>> regexObj = re.compile(r'^\d+$')
							>>> regexObj.search('234423441234')
							<re.Match object; span=(0, 12), match='234423441234'>
						```
				*	通配字符
					-	正则表达式中，. (句点)字符被称为通配字符。它匹配除了换行符以外的所有字符。
						```
							>>> regexObj = re.compile(r'.at')
							>>> regexObj.findall('Tha cat in the hat sat on the flat mat')
							['cat', 'hat', 'sat', 'lat', 'mat']
							#	对于文本flat，只匹配到了lat。
						```
					-	要记住句点字符只匹配一个字符。
					-	要匹配真正的句点，就是用倒斜杠转义：\. 。
					-	用点-星(.*)匹配所有字符。句点字符表示“除换行外所有单个字符” ，星号字符表示“前面字符出现零次或多次” 
						```
							时候想要匹配所有字符串。例如，假定想要匹配字符串'First Name:'，接下来是任意文本，接下来是'Last Name:'，然后又是任意文本。可以用点-星（.*）表示 “任意文本” 。
							>>> nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)') 
							>>> mo = nameRegex.search('First Name: Al Last Name: Sweigart') 
							>>> mo.group(1) 
							'Al' 
							>>> mo.group(2) 
							'Sweigart'
							>>> regexObj = re.compile(r'First Name:(.*)Last Name:(.*)')
							>>> regexRe = regexObj.search('First Name: Kuro Last Name: Neko')
							>>> regexRe.group()
							'First Name: Kuro Last Name: Neko'
							>>> regexRe.group(1)
							' Kuro '
							>>> regexRe.group(2)
							' Neko'
						```
					-	.* 的贪婪模式和非贪婪模式
						```
							#	点-星使用“贪心”模式：它总是匹配尽可能多的文本。要用“非贪心”模式匹配所有文本，就使用点-星和问号。
							>>> regexObj = re.compile(r'<.*>?')
							>>> regexRe = regexObj.search('<To sever man> for dinner.>')
							>>> regexRe
							<re.Match object; span=(0, 27), match='<To sever man> for dinner.>'>
							>>> regexRe.group()
							'<To sever man> for dinner.>'
							>>> regexObject = re.compile(r'<.*?>')
							>>> regexResult = regexObject.search('<To serve man> for dinner.>')
							>>> regexResult.group()
							'<To serve man>'
							>>> regexObj = re.compile(r'<.*>')
							>>> regexRe = regexObj.search('<To serve man> for dinner.>')
							>>> regexRe.group()
							'<To serve man> for dinner.>'
							#	两个正则表达式都可以翻译成“匹配一个左尖括号，接下来是任意字符，接下来是一个右尖括号” 。但是字符串'<To serve man> for dinner.>'对右肩括号有两种可能的匹配。在非贪心的正则表达式中，Python 匹配最短可能的字符串：'<To serve man>'。在贪心版本中，Python 匹配最长可能的字符串：'<To serve man> for dinner.>'。
						```
					-	用点号(.)匹配换行符
						1.	通过**传入 re.DOTALL 作为 re.compile()的第二个参数，可以让句点字符匹配所有字符，包括换行字符**。 
							```
								>>> regexObj = re.compile(r'.*')
								>>> regexRe = regexObj.search('Serve the public trust.\nProtect the innocent.\nUphold the law.')
								>>> regexRe.group()
								'Serve the public trust.'
								>>> regexRe = re.compile(r'.*', re.DOTALL)
								>>> regexObj = re.compile(r'.*', re.DOTALL)
								>>> regexRe = regexObj.search('Serve the public trust.\nProtect the innocent.\nUphold the law.')
								>>> regexRe.group()
								'Serve the public trust.\nProtect the innocent.\nUphold the law.'
							```
			-	正则表达式复习
				*	?匹配零次或一次前面的分组。 
				*	*匹配零次或多次前面的分组。 
				*	+匹配一次或多次前面的分组。 
				*	{n}匹配 n 次前面的分组。 
				*	{n,}匹配 n 次或更多前面的分组。 
				*	{,m}匹配零次到 m 次前面的分组。 
				*	{n,m}匹配至少 n 次、至多 m 次前面的分组。 
				*	{n,m}?或*?或+?对前面的分组进行非贪心匹配。 
				*	^spam 意味着字符串必须以 spam 开始。 
				*	spam$意味着字符串必须以 spam 结束。 
				*	.匹配所有字符，换行符除外。 
				*	\d、\w 和\s 分别匹配数字、单词和空格。 
				*	\D、\W 和\S 分别匹配出数字、单词和空格外的所有字符。 
				*	[abc]匹配方括号内的任意字符（诸如 a、b 或 c） 。 
				*	[âbc]匹配不在方括号内的任意字符。 
			-	不区分大小写的匹配
				*	通常，正则表达式用你指定的大小写匹配文本。但是，有时候你只关心匹配字母，不关心它们是大写或小写。要让正则表达式**不区分大小写，可以向 re.compile()传入 re.IGNORECASE 或 re.I**，作为第二个参数。
				```
					>>> regexObj = re.compile(r'.at', re.IGNORECASE)
					>>> regexObj.findall('The cAt in the FaT saT on the FlAT mat')
					['cAt', 'FaT', 'saT', 'lAT', 'mat']
					>>> regexObj = re.compile(r'robocop', re.I)
					>>> regexRe = regexObj.search('RoboCop is part man,part of machine, all cop.')
					>>> regexRe.group()
					'RoboCop'
					>>> regexObj.search('RoBOCOP protect the innocent.').group()
					'RoBOCOP'
					>>> regexObj.search('AL, why dose your programing book talk about roboCOP so mach?').group()
					'roboCOP'
				```
			-	用sub()方法替换字符串
				*	Regex对象的 sub()方法需要传入两个参数。第一个参数是一个字符串， 用于取代发现的匹配。 第二个参数是一个字符串， 即正则表达式。 sub()方法返回替换完成后的字符串。
					```
						>>> regexObj = re.compile(r'Agent \w+')
						>>> regexObj.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')
						'CENSORED gave the secret documents to CENSORED.'
					```  
				*	你可能需要使用匹配的文本本身，作为替换的一部分。在sub()的第一个参数中，可以输入\1、\2、\3……。表示“在替换中输入分组 1、2、3……的文本” 。 
					```
						#	例如，假定想要隐去密探的姓名，只显示他们姓名的第一个字母。要做到这一点，可以使用正则表达式 Agent (\w)\w*，传入 r'\1****'作为 sub()的第一个参数。字符串中的\1 将由分组 1 匹配的文本所替代，也就是正则表达式的(\w)分组。 
						>>> agentNamesRegex = re.compile(r'Agent (\w)\w*') 
						>>> agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent 
						Eve knew Agent Bob was a double agent.') 
						A**** told C**** that E**** knew B**** was a double agent.'
					```
			-	管理复杂的正则表达式(为复杂的正则表达式添加注释)
				```
					如果要匹配的文本模式很简单，正则表达式就很好。但匹配复杂的文本模式，可能需要长的、费解的正则表达式。你可以告诉re.compile()，忽略正则表达式字符串中的空白符和注释，从而缓解这一点。要实现这种详细模式，可以向 re.compile()传入变量 re.VERBOSE，作为第二个参数。 
					#	你可以将正则表达式放在多行中，并加上注释。
					phoneRegex = re.compile(r'((\d{3}|\(\d{3}\))?(\s|-|\.)?\d{3}(\s|-|\.)\d{4} (\s*(ext|x|ext.)\s*\d{2,5})?)')
					phoneRegex = re.compile(r'''( 
						 (\d{3}|\(\d{3}\))?  						# area code 
						 (\s|-|\.)?   									# separator
						 \d{3}   										# first 3 digits 
						 (\s|-|\.)  										# separator 
						 \d{4}   										# last 4 digits
						 (\s*(ext|x|ext.)\s*\d{2,5})?  		# extension
					)''', re.VERBOSE) 
					#	前面的例子使用了三重引号('")， 创建了一个多行字符串。 这样就可以将正则表达式定义放在多行中，让它更可读。
					正则表达式字符串中的注释规则，与普通的 Python 代码一样：#符号和它后面直到行末的内容，都被忽略。而且，表示正则表达式的多行字符串中，多余的空白字符也不认为是要匹配的文本模式的一部分。这让你能够组织正则表达式，让它更可读。
				```
			-	组合使用re.IGNORECASE, re.DOTALL和re.VERBOSE
				```
					如果你希望在正则表达式中使用 re.VERBOSE 来编写注释，还希望使用re.IGNORECASE 来忽略大小写，该怎么办？遗憾的是，re.compile()函数只接受一个值作为它的第二参数。
					可以使用管道字符（|）将变量组合起来，从而绕过这个限制。管道字符在这里称为“按位或”操作符。 
					如果希望正则表达式不区分大小写，并且句点字符匹配换行，就可以这样构造 re.compile()调用
					regexValue = re.compile(r'foo', re.IGNORECASE | re.DOTALL)
				```
			-	用和不用正则表达式查找文本。example: isPhoneNumber.py
			-	项目：提取文本中的电话号码和E-mail地址。example: phoneAndEmail.py
		*	小结
			```
				虽然计算机可以很快地查找文本，但你必须精确地告诉它要找什么。正则表达式让你精确地指明要找的文本模式。实际上，某些文字处理和电子表格应用提供了查找替换功能，让你使用正则表达式进行查找。 
				Python 自带的 re 模块让你编译Regex对象。该对象有几种方法：search()查找单词匹配，findall()查找所有匹配实例，sub()对文本进行查找和替换。 除本章介绍的语法以外，还有一些正则表达式语法。你可以在官方Python文档中找到更多内容：http://docs.python.org/3/library/re.html。指南网站 http://www.regular- expressions.info/也是很有用的资源。 
			```
		*	正则表达式方法
			-	regexObject = re.compile(r'regexRule')
				regexResult = regexObject.search(string)
			-	re.compile() -- 向 re.compile()传入一个字符串值，表示正则表达式，它将返回一个 Regex 模式对象
			-	regexObject.search() -- 查找传入的字符串，寻找该正则表达式的匹配。如果字符串中没有找到该正则表达式模式，search()方法将返回None。如果找到了该模式，search()方法将**返回一个 Match 对象(regexResult)**。search()将返回一个Match对象，包含被查找字符串中的“第一次”匹配的文本，
			-	regexResult.group() -- 返回被查找字符串中实际匹配的文本。
			-	regexObject.findall() --  查找传入的字符串，寻找该正则表达式的所有匹配。findall()方法将返回一组字符串，包含被查找字符串中的所有匹配。findall()不是返回一个 Match 对象，而是**返回一个字符串列表**，只要在正则表达式中没有分组。列表中的每个字符串都是一段被查找的文本，它匹配该正则表达式。如果在正则表达式中有分组，那么findall将返回元组的列表。每个元组表示一个找到的匹配， 其中的项就是正则表达式中每个分组的匹配字符串。 
				```
					>>> regexObj = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
					>>> regexRe = regexObj.search('Cell: 415-555-9999 Work: 212-555-0000')
					>>> regexRe.group()
					'415-555-9999'
					>>> regexRe.groups()
					()
					# has no groups 
					>>> regexObj = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
					>>> regexRe = regexObj.findall('Cell: 415-555-9999 Work: 212-555-0000')
					>>> regexRe.group()
					Traceback (most recent call last):
					  File "<console>", line 1, in <module>
					AttributeError: 'list' object has no attribute 'group'
					>>> regexRe.groups()
					Traceback (most recent call last):
					  File "<console>", line 1, in <module>
					AttributeError: 'list' object has no attribute 'groups'
					>>> regexRe
					['415-555-9999', '212-555-0000']
					# has groups
					>>> regexObj = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)')
					>>> regexRe = regexObj.findall('Cell: 415-555-9999 Work: 212-555-0000')
					>>> regexRe
					[('415', '555', '9999'), ('212', '555', '0000')]

					作为 findall()方法的返回结果的总结：
					1．如果调用在一个没有分组的正则表达式上，例如\d\d\d-\d\d\d-\d\d\d\d，方法findall()将返回一个匹配字符串的列表，例如['415-555-9999', '212-555-0000']。 
					2．如果调用在一个有分组的正则表达式上，例如(\d\d\d)-(\d\d\d)-(\d\d\d\d)，方法 findall()将返回一个字符串的元组的列表 （每个分组对应一个字符串） ， 例如[('415', '555', '1122'), ('212', '555', '0000')]。 
				```
			-	regexObject.sub() -- 需要传入两个参数。第一个参数是一个字符串， 用于取代发现的匹配。 第二个参数是一个字符串， 即正则表达式。 sub()方法返回替换完成后的字符串。  
				```
					>>> regexObj = re.compile(r'Agent \w+')
					>>> regexObj.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')
					'CENSORED gave the secret documents to CENSORED.'
					>>> agentNameRegex = re.compile(r'Agent (\w)\w*')
					>>> agentNameRegex.sub('\1*****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob is double agent.')
					'\x01***** told \x01***** that \x01***** knew \x01***** is double agent.'
					>>> agentNameRegex.sub('r\1*****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob is double agent.')
					'r\x01***** told r\x01***** that r\x01***** knew r\x01***** is double agent.'
					>>> agentNameRegex.sub(r'\1*****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob is double agent.')
					'A***** told C***** that E***** knew B***** is double agent.'
					>>> agentNameRegex = re.compile(r'Agent (\w)\w+')
					>>> agentNameRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob is double agent.')
					'A**** told C**** that E**** knew B**** is double agent.'
				```

##	Example
	*	example1
		```
			#	比较输入是否大于100

			#!/usr/bin/env python3
			number = int(input("Enter an integer: "))
			if number <= 100:
			    print("Your number is less than or equal to 100")
			else:
			    print("Your number is greater than 100")
		```
	*	example2
		```
			#	计算投资

			#!/usr/bin/env python3
			amount = float(input("Enter amount: "))  # 输入数额
			inrate = float(input("Enter Interest rate: "))  # 输入利率
			period = int(input("Enter period: "))  # 输入期限
			value = 0
			year = 1
			while year <= period:
			    value = amount + (inrate * amount)
			    print("Year {} Rs. {:.2f}".format(year, value))
			    amount = value
			    year = year + 1
		```
	*	example3
		```
			#	求平均数

			#!/usr/bin/env python3
			N = 10
			sum = 0
			count = 0
			print("please input 10 numbers:")
			while count < N:
			    number = float(input())
			    sum = sum + number
			    count = count + 1
			average = sum / N
			print("N = {}, Sum = {}".format(N, sum))
			print("Average = {:.2f}".format(average))
		```
	*	example4
		```
			#	华氏温度转摄氏温度
			#	tip:公式 C = (F - 32) / 1.8 

			#!/usr/bin/env python3
			fahrenheit = 0
			print("Fahrenheit Celsius")
			while fahrenheit <= 250:
			    celsius = (fahrenheit - 32) / 1.8 # 转换为摄氏度
			    print("{:5d} {:7.2f}".format(fahrenheit , celsius))
			    fahrenheit = fahrenheit + 25
			# {:5d} 的意思是替换为 5 个字符宽度的整数，宽度不足则使用空格填充。 {:7.2f}的意思是替换为为 7 个字符宽度的保留两位的小数，小数点也算一个宽度，宽度不足则使用空格填充。其中7指宽度为 7，.2f指保留两位小数。
		```
	*	example5
		```
			#	获取月数和天数
			#	在Enter days:后获得用户输入的天数，然后获得月份数和天数，最后把这些数打印出来
			#	way1

			#!/usr/bin/env python3
			days = int(input("Enter days: "))
			months = days // 30
			days = days % 30
			print("Months = {} Days = {}".format(months, days))

			#	way2
			#	divmod(num1, num2) 返回一个元组，这个元组包含两个值，第一个是 num1 和 num2 相整除得到的值，第二个是 num1 和 num2 求余得到的值，然后我们用 * 运算符拆封这个元组，得到这两个值
			#!/usr/bin/env python3
			days = int(input("Enter days: "))
			print('Months = {}, Days = {}'.format(*divmod(days, 30)))

			#!/usr/bin/env python3
			days = int(input("Enter days: "))
			print("Months = {} Days = {}".format(*divmod(days, 30)))
		```
	*	example6
		```
			#	表达式运算
			#!/usr/bin/env python3
			a = 9
			b = 12
			c = 3
			x = a - b / 3 + c * 2 - 1
			y = a - b / (3 + c) * (2 - 1)
			z = a - (b / (3 + c) * 2) - 1
			print("X = ", x)
			print("Y = ", y)
			print("Z = ", z)
		```
	*	example7
		```
			#	evaluateequ.py
			#	这个程序计算数列 1/x+1/(x+1)+1/(x+2)+ ... +1/n，我们设 x = 1，n = 10
			#!/usr/bin/env python3
			sum = 0
			for i in range(1, 11):
			    sum += 1.0 / i
			    print("{:2d} {:6.4f}".format(i , sum))
		```
	*	example8
		```
			#	quadraticequation.py
			#	这个程序的名称为 quadratic equation 组合，是二次方程的英文词组。
			#!/usr/bin/env python3
			import math
			a = int(input("Enter value of a: "))
			b = int(input("Enter value of b: "))
			c = int(input("Enter value of c: "))
			d = b * b - 4 * a * c
			if d < 0:
			    print("ROOTS are imaginary")
			else:
			    root1 = (-b + math.sqrt(d)) / (2 * a)
			    root2 = (-b - math.sqrt(d)) / (2 * a)
			    print("Root 1 = ", root1)
			    print("Root 2 = ", root2)
		```
	*	example9
		```
			#	salesmansalary.py
			#	这个程序计算一位数码相机销售人员的工资。他的基本工资是 1500，每售出一台相机他可以得到 200 并且获得 2% 的抽成。程序要求输入相机数量及单价。
			#!/usr/bin/env python3
			basic_salary = 1500
			bonus_rate = 200
			commission_rate = 0.02
			numberofcamera = int(input("Enter the number of inputs sold: "))
			price = float(input("Enter the price of camera: "))
			bonus = (bonus_rate * numberofcamera)
			commission = (commission_rate * price * numberofcamera)
			print("Bonus        = {:6.2f}".format(bonus))
			print("Commission   = {:6.2f}".format(commission))
			print("Gross salary = {:6.2f}".format(basic_salary + bonus + commission))

			#	本节实验知识点回顾：

			#	关系/逻辑运算
			#	表达式
			#	类型转换
			#	除了数值运算，关系和逻辑运算也是程序的重要组成部分。另外 Python 是强类型语言，所以必要的时候需要手动进行类型转换。
		```
	*	 example10
		```
			#	Fibonacci.py
			#	斐波那契（Fibonacci）数列
			#	让我们来试试打印斐波那契数列。这个数列前两项为 1，之后的每一个项都是前两项之和。所以这个数列看起来就像这样： 1,1,2,3,5,8,13,...。

			#!/usr/bin/env python3
			a, b = 0, 1
			while b < 100:
			    print(b)
			    a, b = b, a + b
		```
	*	example11
		```
			#	cricleArea.py
			#	圆的面积
			#!/usr/bin/env python3
			import	math

			r = float(input('Please enter r:'))
			area = math.pi * r * r
			print('The cricle's area is {:.5f}'.format(area))
		```
	*	example12
		```
			#	powerseries.py
			#	幂级数，我们来写一个程序计算幂级数：e^x = 1 + x + x^2 / 2! + x^3 / 3! + ... + x^n / n! （0 < x < 1）。

			#!/usr/bin/env python3
			x = float(input("Enter the value of x: "))
			n = term = num = 1
			result = 1.0
			while n <= 100:
			    term *= x / n term = x
			    result += term
			    n += 1
			    if term < 0.0001:
			        break
			print("No of Times= {} and Sum= {}".format(n, result))

			#!/usr/bin/env python3
			x = float(input('Please enter x:'))
			n = int(input('Please enter n:'))
			a = 1
			if 0 < x < 1 :
				resule = 0
				for i in range(1,n + 1):
					resule += x^n / n
				print()
			else :
				print('Please make sure \'0 < x < 1\' . ')
		```
	*	example13
		```
			#	九九乘法表
			str1 = ''
			for i in range(1,10):
				for j in range(1,10):
					if j <= i:
						str1 =+ '{} * {} = {}  '.format(i, j, i*j)
				str =+ '\n'
			print(str1)
		```
	*	example14
		```
			#	multiplication.py
			#	乘法表
			#	打印10以内的乘法表

			#!/usr/bin/env python3
			i = 1
			print("-" * 50)
			while i < 11:
			    n = 1
			    while n <= 10:
			        print("{:5d}".format(i * n), end=' ')
			        n += 1
			    print()
			    i += 1
			print("-" * 50)

			#!/usr/bin/env python3
			str1 = ''
			for i in range(1,11):
				for j in range(1,11):
					str1 += '{} * {} = {}  '.format(i, j, i * j)
				str1 += '\n'
			print(str1)
		```
	*	example15
		```
			#	打印星号练习
			#	design1.py
			n = int(input('Please enter the number of rows:'))
			while n > 0:
				print('*' * n)
				n -= 1

			# design2.py
			n = int(input('Please enter the number of rows:'))
			i = 1
			while i <= n:
				print('*' * i)
				i += 1

			# design3.py
			#!/usr/bin/env python3
			row = int(input("Enter the number of rows: "))
			n = row
			while n >= 0:
			    x = "*" * n
			    y = " " * (row - n)
			    print(y + x)
			    n -= 1

			row = n = int(input('Please enter the number of rows:'))
			while n > 0:
				x = '*' * n
				y = ' ' * (row - n)
				print(y + x)
				n -= 1
		```
